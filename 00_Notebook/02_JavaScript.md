# JavaScript
## Basic
### 编写位置
- 可以将js代码编写到外部js文件中然后通过script标签引入.(推荐使用的方式)
  - 写到外部文件中可以在不同的页面中同时引用，也可以利用到浏览器的缓存机制.
  - script标签一旦用于引入外部文件了，就不能在编写代码了，即使编写了浏览器也会忽略
  - 如果需要则可以在创建一个新的script标签用于编写内部代码
- 可以将js代码编写到script标签	`<script type="text/javascript">`
- 可以将js代码编写到标签的onclick属性中
  - 当我们点击按钮时，js代码才会执行			
  - 虽然可以写在标签的属性中，但是他们属于结构与行为耦合，不方便维护，不推荐使用
- 可以将js代码写在超链接的href属性中，这样当点击超链接时，会执行js代码

### 基本语法
1. JS中严格区分大小写
2. JS中每一条语句以分号(;)结尾
   - 如果不写分号，浏览器会自动添加，但是会消耗一些系统资源，
   - 而且有些时候，浏览器会加错分号，所以在开发中分号必须写
3. JS中会忽略多个空格和换行，所以我们可以利用空格和换行对代码进行格式化
4. 注释:
   - 单行注释
   - 多行注释，注释中的内容不会被执行，但是可以在源代码中查看
   - 要养成良好的编写注释的习惯，也可以通过注释来对代码进行一些简单的调试

### 字面量和变量
- 字面量，都是一些不可改变的值，比如 ：1 2 3 4 5。
  - 字面量都是可以直接使用，但是我们一般都不会直接使用字面量
- 变量，可以用来保存字面量，而且变量的值是可以任意改变的
  - 变量更加方便我们使用，所以在开发中都是通过变量去保存一个字面量，
  - 而很少直接使用字面量
  - 可以通过变量对字面量进行描述
  - 在js中使用var关键字来声明一个变量

### 标识符
- 在JS中所有的可以由我们自主命名的都可以称为是标识符
- 例如：变量名、函数名、属性名都属于标识符
- 命名一个标识符时需要遵守如下的规则：
  1. 标识符中可以含有字母、数字、_、$
  2. 标识符不能以数字开头
  3. 标识符不能是ES中的关键字或保留字
  4. 标识符一般都采用驼峰命名法:首字母小写，每个单词的开头字母大写，其余字母小写 helloWorld xxxYyyZzz
- JS底层保存标识符时实际上是采用的Unicode编码，所以理论上讲，所有的utf-8中含有的内容都可以作为标识符

## 数据类型
### 数据类型
- 数据类型指的就是字面量的类型
- 在JS中一共有六种数据类型
  - String 字符串
  - Number 数值
  - Boolean 布尔值
  - Null 空值
  - Undefined 未定义
  - Object 对象
- 其中String Number Boolean Null Undefined属于基本数据类型,而Object属于引用数据类型
- 可以使用一个运算符 typeof 来检查一个变量的类型
  - 语法：typeof 变量
  - 检查字符串时，会返回string
  - 检查数值时，会返回number
- 数据类型的分类和判断
  - 基本(值)类型
    - Number ----- 任意数值 -------- typeof
    - String ----- 任意字符串 ------ typeof
    - Boolean ---- true/false ----- typeof
    - undefined --- undefined ----- typeof/===
    - null -------- null ---------- ===
  - 对象(引用)类型
    - Object ----- typeof/instanceof
    - Array ------ instanceof
    - Function ---- typeof

#### 数据,变量,内存的理解
- 什么是数据?
  - 在内存中可读的, 可传递的保存了特定信息的'东东'
  - 一切皆数据, 函数也是数据
  - 在内存中的所有操作的目标: 数据
- 什么是变量?
  - 在程序运行过程中它的值是允许改变的量
  - 一个变量对应一块小内存, 它的值保存在此内存中  
- 什么是内存?
  - 内存条通电后产生的存储空间(临时的)
  - 一块内存包含2个方面的数据
    - 内部存储的数据
    - 地址值数据
  - 内存空间的分类
    - 栈空间: 全局变量和局部变量
    - 堆空间: 对象 
- 内存,数据, 变量三者之间的关系
  - 内存是容器, 用来存储不同数据
  - 变量是内存的标识, 通过变量我们可以操作(读/写)内存中的数据  

#### String 字符串
- 在JS中字符串需要使用引号引起来
- 使用双引号或单引号都可以，但是不要混着用
- 引号不能嵌套，双引号不能放双引号，单引号不能放单引号
- 在字符串中我们可以使用\作为转义字符，当表示一些特殊符号时可以使用\进行转义
  - `\" 表示 "`
  - `\' 表示 '`
  - `\n 表示换行 Space`
  - `\t 制表符 Tab`
  - `\\ 表示\`

#### Number
- 在JS中所有的数值都是Number类型，包括整数和浮点数（小数）
- JS中可以表示的数字的最大值 Number.MAX_VALUE = 1.7976931348623157e+308
- 大于0的最小值 Number.MIN_VALUE = 5e-324
- 如果使用Number表示的数字超过了最大值，则会返回一个
  - Infinity 表示正无穷
  - Infinity 表示负无穷
  - 使用typeof检查Infinity也会返回number
- NaN 是一个特殊的数字，表示Not A Number
  - 使用typeof检查一个NaN也会返回number
- 在JS中整数的运算基本可以保证精确 `var c = 1865789 + 7654321;`
- 如果使用JS进行浮点运算，可能得到一个不精确的结果,所以千万不要使用JS进行对精确度要求比较高的运算`var c = 0.1 + 0.2;`

#### Boolean 布尔值
- 布尔值只有两个，主要用来做逻辑判断
  - true 表示真
  - false 表示假
- 使用typeof检查一个布尔值时，会返回boolean

#### Null 空值 & Undefined 未定义
- Null
  - Null（空值）类型的值只有一个，就是null
  - null这个值专门用来表示一个为空的对象
  - 使用typeof检查一个null值时，会返回object
- Undefined
  - Undefined（未定义）类型的值只有一个，就undefind
  - 当声明一个变量，但是并不给变量赋值时，它的值就是undefined
  - 使用typeof检查一个undefined时也会返回undefined

### 强制类型转换
- 指将一个数据类型强制转换为其他的数据类型
- 类型转换主要指，将其他的数据类型，转换为 String Number Boolean

#### 将其他的数据类型转换为String
- 方式一：
  - 调用被转换数据类型的toString()方法
  - 该方法不会影响到原变量，它会将转换的结果返回
  - 但是注意：null和undefined这两个值没有toString()方法，如果调用他们的方法，会报错
- 方式二：
  - 调用String()函数，并将被转换的数据作为参数传递给函数
  - 使用String()函数做强制类型转换时，
    - 对于Number和Boolean实际上就是调用的toString()方法
    - 但是对于null和undefined，就不会调用toString()方法
      - 它会将 null 直接转换为 "null"
      - 将 undefined 直接转换为 "undefined"

#### 将其他的数据类型转换为Number
- 方式一：
  - 使用Number()函数
    - 字符串 --> 数字
      1. 如果是纯数字的字符串，则直接将其转换为数字
      2. 如果字符串中有非数字的内容，则转换为NaN
      3. 如果字符串是一个空串或者是一个全是空格的字符串，则转换为0
	- 布尔 --> 数字
      - true 转成 1
      - false 转成 0
      - null --> 数字 0
      - undefined --> 数字 NaN
- 方式二：
  - 这种方式专门用来对付字符串
  - parseInt() 把一个字符串转换为一个整数，可以将一个字符串中的有效的整数内容去出来，然后转换为Number
  - parseFloat() 把一个字符串转换为一个浮点数，作用和parseInt()类似，不同的是它可以获得有效的小数
  - 如果对非String使用parseInt()或parseFloat()，它会先将其转换为String然后在操作
- 其他的进制的数字
  - 在js中，如果需要表示16进制的数字，则需要以0x开头
  - 如果需要表示8进制的数字，则需要以0开头
  - 如果要要表示2进制的数字，则需要以0b开头
  - 但是不是所有的浏览器都支持
  - 像"070"这种字符串，有些浏览器会当成8进制解析，有些会当成10进制解析
  - 可以在parseInt()中传递一个第二个参数，来指定数字的进制

#### 将其他的数据类型转换为Boolean
- 使用Boolean()函数
  - 数字 ---> 布尔
    - 除了0和NaN，其余的都是true
  - 字符串 ---> 布尔
	- 除了空串，其余的都是true
  - null和undefined都会转换为false
  - 对象也会转换为true

## 运算符
- 通过运算符可以对一个或多个值进行运算,并获取运算结果
- 比如：typeof就是运算符，可以来获得一个值的类型
  - 它会将该值的类型以字符串的形式返回
  - number string boolean undefined object

### 算数运算符
- 当对非Number类型的值进行运算时，会将这些值转换为Number然后在运算
- 任何值和NaN做运算都得NaN
- `+` 可以对两个值进行加法运算，并将结果返回
  - 如果对两个字符串进行加法运算，则会做拼串，会将两个字符串拼接为一个字符串，并返回
  - 任何的值和字符串做加法运算，都会先转换为字符串，然后再和字符串做拼串的操作
- `-` 可以对两个值进行减法运算，并将结果返回
- `*` 可以对两个值进行乘法运算
- `/` 可以对两个值进行除法运算
- `%` 取模运算（取余数）

### 隐式类型转换
- 任何值和字符串相加都会转换为字符串，并做拼串操作
  - 我们可以利用这一特点，来将一个任意的数据类型转换为String
  - 我们只需要为任意的数据类型 + 一个 "" 即可将其转换为String
  - 这是一种隐式的类型转换，由浏览器自动完成，实际上它也是调用String()函数
    ```			
    var c = 123;			
    c = c + "";
    ```
- 任何值做- * /运算时都会自动转换为Number
  - 我们可以利用这一特点做隐式的类型转换
  - 可以通过为一个值 `-0 *1 /1`来将其转换为Number
  - 原理和Number()函数一样，使用起来更加简单
    ```
    var d = "123";
    d = d - 0;
    ```

### 一元运算符
- 一元运算符，只需要一个操作数
- `+` 正号
  - 正号不会对数字产生任何影响
- `-` 负号
  - 负号可以对数字进行负号的取反
- 对于非Number类型的值，
  - 它会将先转换为Number，然后在运算
  - 可以对一个其他的数据类型使用+,来将其转换为number
  - 它的原理和Number()函数一样

### 自增自减
- 自增 `++`
  - 通过自增可以使变量在自身的基础上增加1
  - 对于一个变量自增以后，原变量的值会立即自增1
  - 自增分成两种：后`++(a++)` 和 前`++(++a)`	
	- 无论是`a++` 还是 `++a`，都会立即使原变量的值自增1
	- 不同的是`a++` 和 `++a`的值不同
      - `a++`的值等于原变量的值（自增前的值）
      - `++a`的值等于新值 （自增后的值）
- 自减 `--`
  - 通过自减可以使变量在自身的基础上减1
  - 自减分成两种：后`--(a--)` 和 前`--(--a)`
  - 无论是`a--` 还是 `--a` 都会立即使原变量的值自减1
    - 不同的是`a--` 和 `--a`的值不同
      - `a--` 是变量的原值（自减前的值）
      - `--a` 是变量的新值（自减以后的值）

### 逻辑运算符
- JS中为我们提供了三种逻辑运算符
- `!` 非
  - `!`可以用来对一个值进行非运算
  - 所谓非运算就是值对一个布尔值进行取反操作，true变false，false变true
  - 如果对一个值进行两次取反，它不会变化
  - 如果对非布尔值进行元素，则会将其转换为布尔值，然后再取反
    - 所以我们可以利用该特点，来将一个其他的数据类型转换为布尔值
    - 可以为一个任意数据类型取两次反，来将其转换为布尔值，
    - 原理和Boolean()函数一样
- `&&` 与
  - `&&`可以对符号两侧的值进行与运算并返回结果
  - 运算规则
    - 两个值中只要有一个值为false就返回false，只有两个值都为true时，才会返回true
    - JS中的“与”属于短路的与，如果第一个值为false，则不会看第二个值
- `||` 或
  - `||`可以对符号两侧的值进行或运算并返回结果
  - 运算规则：
    - 两个值中只要有一个true，就返回true
    - 如果两个值都为false，才返回false
    - JS中的“或”属于短路的或,如果第一个值为true，则不会检查第二个值
- `&&` `||` 非布尔值的情况
  - 对于非布尔值进行与或运算时，会先将其转换为布尔值，然后再运算，并且返回原值
  - 与运算：
    - 如果第一个值为true，则必然返回第二个值
    - 如果第一个值为false，则直接返回第一个值
  - 或运算
	- 如果第一个值为true，则直接返回第一个值
	- 如果第一个值为false，则返回第二个值

### 赋值运算符
- `=` 可以将符号右侧的值赋值给符号左侧的变量
- `+=` `a += 5` 等价于 `a = a + 5`
- `-=` `a -= 5` 等价于 `a = a - 5`
- `*=` `a *= 5` 等价于 `a = a * 5`
- `/=` `a /= 5` 等价于 `a = a / 5`
- `%=` `a %= 5` 等价于 `a = a % 5`

### 关系运算符
- 通过关系运算符可以比较两个值之间的大小关系，如果关系成立它会返回true，如果关系不成立则返回false
- `>` 大于号
  - 判断符号左侧的值是否大于右侧的值
  - 如果关系成立，返回true，如果关系不成立则返回false
- `>=` 大于等于
  - 判断符号左侧的值是否大于或等于右侧的值
- `<` 小于号
- `<=` 小于等于
- 非数值的情况
  - 对于非数值进行比较时，会将其转换为数字然后在比较
  - 如果符号两侧的值都是字符串时，不会将其转换为数字进行比较,而会分别比较字符串中字符的Unicode编码
- 在网页中使用Unicode编码
  - &#编码; 这里的编码需要的是10进制
  `<h1 style="font-size: 200px;">&#9760;</h1>`

### 相等运算符
- 相等运算符用来比较两个值是否相等，
- 如果相等会返回true，否则返回false
-  `==` 相等运算 Equality
  - 当使用`==`来比较两个值时，如果值的类型不同，
  - 则会自动进行类型转换，将其转换为相同的类型，
  - 然后在比较
- `!=` 不相等运算
  - 不相等用来判断两个值是否不相等，如果不相等返回true，否则返回false
  - 不相等也会对变量进行自动的类型转换，如果转换后相等它也会返回false
- `===` 全等 Strict Equality
  - 用来判断两个值是否全等，它和相等类似，不同的是它不会做自动的类型转换
  - 如果两个值的类型不同，直接返回false
- `!==` 不全等
  - 用来判断两个值是否不全等，和不等类似，不同的是它不会做自动的类型转换
  - 如果两个值的类型不同，直接返回true
- undefined 衍生自 null,所以这两个值做相等判断时，会返回true
- 可以通过isNaN()函数来判断一个值是否是NaN, 如果该值是NaN则返回true，否则返回false

### 条件运算符 三元运算符
- 语法：条件表达式?语句1:语句2;
- 执行的流程：
  - 条件运算符在执行时，首先对条件表达式进行求值，
  - 如果该值为true，则执行语句1，并返回执行结果
  - 如果该值为false，则执行语句2，并返回执行结果
  - 如果条件的表达式的求值结果是一个非布尔值，会将其转换为布尔值然后在运算

### 运算符的优先级
- `,`运算符
  - 使用`,`可以分割多个语句，一般可以在声明多个变量时使用
  - 使用`,`运算符同时声明多个变量 `var a , b , c;`
  - 可以同时声明多个变量并赋值`var a=1 , b=2 , c=3;`
- 就和数学中一样，在JS中运算符也有优先级，比如：先乘除 后加减
- 在JS中有一个运算符优先级的表，在表中越靠上优先级越高，优先级越高越优先计算，如果优先级一样，则从左往右计算。
- 但是这个表我们并不需要记忆，如果遇到优先级不清楚，可以使用()来改变优先级

## 流程控制
### 代码块
- 我们的程序是由一条一条语句构成的 statement
- 语句是按照自上向下的顺序一条一条执行的
- 在JS中可以使用`{}`来为语句进行分组,
- 同一个`{}`中的语句我们称为是一组语句，它们要么都执行，要么都不执行，
- 一个`{}`中的语句我们也称为叫一个代码块
- 在代码块的后边就不用再编写`;`了
- JS中的代码块，只具有分组的的作用，没有其他的用途
- 代码块内容的内容，在外部是完全可见的

### 流程控制语句
- JS中的程序是从上到下一行一行执行的
- 通过流程控制语句可以控制程序执行流程，使程序可以根据一定的条件来选择执行
- 语句的分类：
  1. 条件判断语句
  2. 条件分支语句
  3. 循环语句

#### 条件判断语句 if语句
- 使用条件判断语句可以在执行某个语句之前进行判断，如果条件成立才会执行语句，条件不成立则语句不执行。
- 语法一：
    ```
    if(条件表达式){	    
        语句...
    }
    ```
  - if语句在执行时，会先对条件表达式进行求值判断，
  - 如果条件表达式的值为true，则执行if后的语句，
  - 如果条件表达式的值为false，则不会执行if后的语句。
  - if语句只能控制紧随其后的那个语句,如果希望if语句可以控制多条语句，可以将这些语句统一放到代码块中	- if语句后的代码块不是必须的，但是在开发中尽量写上代码块，即使if后只有一条语句
- 语法二:
    ```
    if(条件表达式){
        语句...
    }else{
        语句...
    }
    ```
  - `if...else...`语句
  - 当该语句执行时，会先对if后的条件表达式进行求值判断，
  - 如果该值为true，则执行if后的语句
  - 如果该值为false，则执行else后的语句
- 语法三：
    ```
    if(条件表达式){
      语句...
    }else if(条件表达式){
    	语句...
    }else if(条件表达式){
    	语句...
    }else{
    	语句...
    }
    ```
- `if...else if...else`
- 当该语句执行时，会从上到下依次对条件表达式进行求值判断
- 如果值为true，则执行当前语句。
- 如果值为false，则继续向下判断。
- 如果所有的条件都不满足，则执行最后一个else后的语句
- 该语句中，只会有一个代码块被执行，一旦代码块执行了，则直接结束语句

#### 条件分支语句 switch语句
- 语法：
    ```
    switch(条件表达式){
      case 表达式:
          语句...
          break;
      case 表达式:
          语句...
          break;
      default:
          语句...
          break;
    	}
    ```
- 执行流程：
  - switch...case..语句在执行时会依次将case后的表达式的值和switch后的条件表达式的值进行全等比较，
  - 如果比较结果为true，则从当前case处开始执行代码。
  - 当前case后的所有的代码都会执行，我们可以在case的后边跟着一个break关键字，
  - 这样可以确保只会执行当前case后的语句，而不会执行其他的case
  - 如果比较结果为false，则继续向下比较
  - 如果所有的比较结果都为false，则只执行default后的语句
  - switch语句和if语句的功能实际上有重复的，使用switch可以实现if的功能，
  - 同样使用if也可以实现switch的功能，所以我们使用时，可以根据自己的习惯选择。

#### 循环语句
- 通过循环语句可以反复的执行一段代码多次
- while循环
  - 语法：
    ```
    while(条件表达式){
        语句...
    }
    ```
  - 执行流程
    - while语句在执行时，先对条件表达式进行求值判断，
    - 如果值为true，则执行循环体，
      - 循环体执行完毕以后，继续对表达式进行判断
      - 如果为true，则继续执行循环体，以此类推
    - 如果值为false，则终止循环
- do...while循环
  - 语法：
    ```
    do{
	    语句...
	}while(条件表达式)
  - 执行流程：
    - do...while语句在执行时，会先执行循环体，
      - 循环体执行完毕以后，在对while后的条件表达式进行判断，
      - 如果结果为true，则继续执行循环体，执行完毕继续判断以此类推
      - 如果结果为false，则终止循环
    - 实际上这两个语句功能类似，不同的是while是先判断后执行，
      - 而do...while会先执行后判断，
    - do...while可以保证循环体至少执行一次，
      - 而while不能
- 死循环
  `var n = 1;`
  - 向这种将条件表达式写死为true的循环，叫做死循环
  - 该循环不会停止，除非浏览器关闭，死循环在开发中慎用
  - 可以使用break，来终止循环
    ```
    while(true){
	alert(n++);
	//判断n是否是10
	if(n == 10){
	//退出循环
	break;
    }
    ```
- for循环
  - 在for循环中，为我们提供了专门的位置用来放三个表达式：
    1. 初始化表达式
    2. 条件表达式
    3. 更新表达式
  - for循环的语法：
    - for(①初始化表达式;②条件表达式;④更新表达式){
		③语句...
        }
  - for循环的执行流程：
    - ①执行初始化表达式，初始化变量（初始化表达式只会执行一次）
    - ②执行条件表达式，判断是否执行循环。
      - 如果为true，则执行循环③
      - 如果为false，终止循环
    - ④执行更新表达式，更新表达式执行完毕继续重复②
  - for循环中的三个部分都可以省略，也可以写在外部
    - 如果在for循环中不写任何的表达式，只写两个;
    - 此时循环是一个死循环会一直执行下去，慎用

#### break & continue
- break 关键字可以用来退出switch或循环语句
  - 不能在if语句中使用break和continue
  - break关键字，会立即终止离他最近的那个循环语句
    ```
    for(var i=0 ; i<5 ; i++){
		console.log(i);
		if(i == 2){
		break;
        }}
    ```
  - 可以为循环语句创建一个label，来标识当前的循环
  - label:循环语句
  - 使用break语句时，可以在break后跟着一个label，这样break将会结束指定的循环，而不是最近的
    ```
    outer:
	for(var i=0 ; i<5 ; i++){
		console.log("@外层循环"+i)
		for(var j=0 ; j<5; j++){
		break outer;
		console.log("内层循环:"+j);
		}
	}
    ```
- continue 关键字可以用来跳过当次循环
  - 同样continue也是默认只会对离他最近的循环循环起作用
    ```
    for(var i=0 ; i<5 ; i++){		
	    if(i==2){
		    continue;
		}		
	    console.log(i);
	}
    ```

## Object
### 对象 Object
- 对象是JS中的引用数据类型
- 对象属于一种复合的数据类型，在对象中可以保存多个不同数据类型的属性。
- 对象的分类：
  1. 内建对象
     - 由ES标准中定义的对象，在任何的ES的实现中都可以使用
     - 比如：Math String Number Boolean Function Object....
  2. 宿主对象
     - 由JS的运行环境提供的对象，目前来讲主要指由浏览器提供的对象
     - 比如 BOM DOM
  3. 自定义对象
     - 由开发人员自己创建的对象
- 创建对象
  - 使用new关键字调用的函数，是构造函数constructor
  - 构造函数是专门用来创建对象的函数
  - 方式一：
		- var obj = new Object();
	- 方式二：
		- var obj = {};
- 使用typeof检查一个对象时，会返回object

#### 对象的创建模式
- Object构造函数模式
  ```
  var obj = {};
  obj.name = 'Tom'
  obj.setName = function(name){this.name=name}
  ```
- 对象字面量模式
  ```
  var obj = {
    name : 'Tom',
    setName : function(name){this.name = name}
  }
  ```
- 构造函数模式
  ```
  function Person(name, age) {
    this.name = name;
    this.age = age;
    this.setName = function(name){this.name=name;};
  }
  new Person('tom', 12);
  ```
- 构造函数+原型的组合模式
  ```
  function Person(name, age) {
    this.name = name;
    this.age = age;
  }
  Person.prototype.setName = function(name){this.name=name;};
  new Person('tom', 12);
  ```

#### 对象继承模式
- 原型链继承 : 得到方法
  ```
  function Parent(){}
  Parent.prototype.test = function(){};
  function Child(){}
  Child.prototype = new Parent(); // 子类型的原型指向父类型实例
  Child.prototype.constructor = Child
  var child = new Child(); //有test()
  ```
- 借用构造函数 : 得到属性
  ```
  function Parent(xxx){this.xxx = xxx}
  Parent.prototype.test = function(){};
  function Child(xxx,yyy){
      Parent.call(this, xxx);//借用构造函数   this.Parent(xxx)
  }
  var child = new Child('a', 'b');  //child.xxx为'a', 但child没有test()
  ```
- 组合
  ```
  function Parent(xxx){this.xxx = xxx}
  Parent.prototype.test = function(){};
  function Child(xxx,yyy){
      Parent.call(this, xxx);//借用构造函数   this.Parent(xxx)
  }
  Child.prototype = new Parent(); //得到test()
  var child = new Child(); //child.xxx为'a', 也有test()
  ```
- new一个对象背后做了些什么?
  * 创建一个空对象
  * 给对象设置__proto__, 值为构造函数对象的prototype属性值   this.__proto__ = Fn.prototype
  * 执行构造函数体(给对象添加属性/方法)

#### 对象的理解和使用
- 什么是对象?
  - 多个数据(属性)的集合
  - 用来保存多个数据(属性)的容器
- 属性组成:
  - 属性名 : 字符串(标识)
  - 属性值 : 任意类型
- 属性的分类:
  - 一般 : 属性值不是function  描述对象的状态
  - 方法 : 属性值为function的属性  描述对象的行为
- 特别的对象
  - 数组: 属性名是0,1,2,3之类的索引
  - 函数: 可以执行的
- 如何操作内部属性(方法)
  - .属性名
  - ['属性名']: 属性名有特殊字符/属性名是一个变量

#### 属性名和属性值
- 在对象中保存的值称为属性
  - 语法：对象.属性名 = 属性值;
  - 属性名：
    - 对象的属性名不强制要求遵守标识符的规范,什么乱七八糟的名字都可以使用
    - 但是我们使用是还是尽量按照标识符的规范去做
    - 如果要使用特殊的属性名，不能采用.的方式来操作
      - 需要使用另一种方式：语法：对象`["属性名"] = 属性值`
      - 读取时也需要采用这种方式
      - 使用`[]`这种形式去操作属性，更加的灵活，在`[]`中可以直接传递一个变量，这样变量值是多少就会读取那个属性
  - 属性值:
    - JS对象的属性值，可以是任意的数据类型
    - 甚至也可以是一个对象
    - 也可以是个函数 
      - 函数也可以称为对象的属性，
      - 如果一个函数作为一个对象的属性保存，那么我们称这个函数时这个对象的方法（method）
      - 调用这个函数就说调用对象的方法
      - 但是它只是名称上的区别没有其他的区别
  - in 运算符
    - 通过该运算符可以检查一个对象中是否含有指定的属性
      - 如果有则返回true，没有则返回false
    - 语法："属性名" in 对象
- 读取对象中的属性
  - 语法：对象.属性名
  - 如果读取对象中没有的属性，不会报错而是会返回undefined
- 修改对象的属性值
  - 语法：
    - 对象.属性名 = 属性值;
		- 对象["属性名"] = 属性值;
	- 对象的属性名没有任何要求，不需要遵守标识符的规范，
		但是在开发中，尽量按照标识符的要求去写。
	- 属性值也可以任意的数据类型。
- 删除对象的属性
  - 语法：delete 对象.属性名
- 使用对象字面量，在创建对象时直接向对象中添加属性
  - 语法：
  ```
  var obj = {
							属性名:属性值,
							属性名:属性值,
							属性名:属性值,
							属性名:属性值
					  }
  ``` 
  - 枚举对象中的属性
    - 使用for...in 语句
    - 语法： 
      `for(var 属性名  in 对象){}`
    - 对象中有几个属性，循环体就会执行几次
    - 每次执行时，会将对象中的一个属性的名字赋值给变量

#### 基本数据类型 & 引用数据类型
- 基本数据类型：String Number Boolean Null Undefined
- 引用数据类型：Object
- JS中的变量都是保存到栈内存中的，
  - 基本数据类型的值直接在栈内存中存储，
  - 值与值之间是独立存在，修改一个变量不会影响其他的变量
  - 对象是保存到堆内存中的，每创建一个新的对象，就会在堆内存中开辟出一个新的空间，
  - 而变量保存的是对象的内存地址（对象的引用），如果两个变量保存的是同一个对象引用，
  - 当一个通过一个变量修改属性时，另一个也会受到影响
- 当比较两个基本数据类型的值时，就是比较值。
- 而比较两个引用数据类型时，它是比较的对象的内存地址，
  - 如果两个对象是一摸一样的，但是地址不同，它也会返回false

#### 对象字面量
- 使用对象字面量，可以在创建对象时，直接指定对象中的属性
- 语法：{属性名:属性值,属性名:属性值....}
  - 对象字面量的属性名可以加引号也可以不加，建议不加,
  - 如果要使用一些特殊的名字，则必须加引号
- 属性名和属性值是一组一组的名值对结构，
  - 名和值之间使用:连接，多个名值对之间使用,隔开
  - 如果一个属性之后没有其他的属性了，就不要写,

### 函数 Function
- 函数也是一个对象
- 函数中可以封装一些功能（代码），在需要时可以执行这些功能（代码）
- 函数中可以保存一些代码在需要的时候调用
- 使用typeof检查一个函数对象时，会返回function
- 我们在实际开发中很少使用构造函数来创建一个函数对象
- 封装到函数中的代码不会立即执行
  - 函数中的代码会在函数调用的时候执行
  - 调用函数 语法：函数对象()
  - 当调用函数时，函数中封装的代码会按照顺序执行
    `fun();`

#### 函数的理解和使用
- 什么是函数?
  - 用来实现特定功能的, n条语句的封装体
  - 只有函数类型的数据是可以执行的, 其它的都不可以
- 为什么要用函数?
  - 提高复用性
  - 便于阅读交流
- 函数也是对象
  - instanceof Object===true
  - 函数有属性: prototype
  - 函数有方法: call()/apply()
  - 可以添加新的属性/方法
- 函数的3种不同角色
  - 一般函数 : 直接调用
  - 构造函数 : 通过new调用
  - 对象 : 通过.调用内部的属性/方法
- 函数中的this
  - 显式指定谁: obj.xxx()
  - 通过call/apply指定谁调用: xxx.call(obj)
  - 不指定谁调用: xxx()  : window
  - 回调函数: 看背后是通过谁来调用的: window/其它
- 匿名函数自调用:
  ```
  (function(w, obj){
    //实现代码
  })(window, obj)
  ```
  - 专业术语为: IIFE (Immediately Invoked Function Expression) 立即调用函数表达式						  
- 回调函数的理解
  - 什么函数才是回调函数?
    - 你定义的
    - 你没有调用
    - 但它最终执行了(在一定条件下或某个时刻)
  - 常用的回调函数
    - dom事件回调函数
    - 定时器回调函数
    - ajax请求回调函数(后面讲解)
    - 生命周期回调函数(后面讲解)

#### 创建一个函数对象
- 构造函数
  - 可以将要封装的代码以字符串的形式传递给构造函数
  - `var fun = new Function("console.log('Hello 这是我的第一个函数');");`
- 函数声明
  - 语法：
    ```
    function 函数名([形参1,形参2...形参N]){
      语句...
    }
    ```
- 函数表达式
  - 语法：
  ```
  var 函数名  = function([形参1,形参2...形参N]){
    语句....
  }
  ```

#### 函数的参数
- 定义一个用来求两个数和的函数
  - 可以在函数的()中来指定一个或多个形参（形式参数）
  - 多个形参之间使用,隔开，声明形参就相当于在函数内部声明了对应的变量
  - 但是并不赋值
- 在调用函数时，可以在()中指定实参（实际参数）
  - 实参将会赋值给函数中对应的形参
- 调用函数时解析器不会检查实参的类型,
  - 所以要注意，是否有可能会接收到非法的参数，如果有可能则需要对参数进行类型的检查
  - 函数的实参可以是任意的数据类型
- 调用函数时，解析器也不会检查实参的数量
  - 多余实参不会被赋值
  - 如果实参的数量少于形参的数量，则没有对应实参的形参将是undefined

#### 返回值
- 可以使用 return 来设置函数的返回值
- 语法：`return 值`
- return后的值将会会作为函数的执行结果返回，
  - 可以定义一个变量，来接收该结果
- return后边的代码都不会执行，一旦执行到return语句时，函数将会立刻退出。
- 如果return语句后不跟任何值就相当于返回一个undefined，
- 如果函数中不写return，则也会返回undefined
- return后可以跟任意类型的值,也可以是一个对象，也可以是一个函数
- break、continue和return
	- break 退出循环
	- continue 跳过当次循环
	- return 退出函数
- 参数，函数的实参也可以是任意的数据类型。
- 调用函数
  - 变量result的值就是函数的执行结果
  - 函数返回什么result的值就是什么
- 方法（method）
	- 可以将一个函数设置为一个对象的属性，当一个对象的属性是一个函数时，我们称这个函数是该对象的方法。
	- 对象.方法名();
	- 函数名();	

#### 立即执行函数 IIFE immediately-invoked function expression 
- 函数对象()
- 函数定义完，立即被调用，这种函数叫做立即执行函数
- 立即执行函数往往只会执行一次
```
(function(a,b){
	console.log("a = "+a);
	console.log("b = "+b);
})(123,456);
```

#### 作用域与作用域链 Scope
- 作用域指一个变量的作用的范围
- 在JS中一共有两种作用域：
  1. 全局作用域
  - 直接编写在script标签中的JS代码，都在全局作用域
  - 全局作用域在页面打开时创建，在页面关闭时销毁
  - 在全局作用域中有一个全局对象window，它代表的是一个浏览器的窗口，它由浏览器创建我们可以直接使用
  - 在全局作用域中：
    - 创建的变量都会作为window对象的属性保存
    - 创建的函数都会作为window对象的方法保存
    - 全局作用域中的变量都是全局变量，在页面的任意的部分都可以访问的到
  2. 函数作用域
    - 调用函数时创建函数作用域，函数执行完毕以后，函数作用域销毁
    - 每调用一次函数就会创建一个新的函数作用域，他们之间是互相独立的
    - 在函数作用域中可以访问到全局作用域的变量
      - 在全局作用域中无法访问到函数作用域的变量
    - 当在函数作用域操作一个变量时，它会先在自身作用域中寻找，如果有就直接使用
      - 如果没有则向上一级作用域中寻找，直到找到全局作用域，
      - 如果全局作用域中依然没有找到，则会报错ReferenceError
    - - 在函数中要访问全局变量可以使用window对象
- 总结
  - 理解:
    - 作用域: 一块代码区域, 在编码时就确定了, 不会再变化
    - 作用域链: 多个嵌套的作用域形成的由内向外的结构, 用于查找变量
  - 分类:
    - 全局
    - 函数
    - js没有块作用域(在ES6之前)
  - 作用
    - 作用域: 隔离变量, 可以在不同作用域定义同名的变量不冲突
    - 作用域链: 查找变量
  - 区别作用域与执行上下文
    - 作用域: 静态的, 编码时就确定了(不是在运行时), 一旦确定就不会变化了
    - 执行上下文: 动态的, 执行代码时动态创建, 当执行结束消失
    - 联系: 执行上下文环境是在对应的作用域中的

#### 闭包 Closures
- 理解:
  - 当嵌套的内部函数引用了外部函数的变量时就产生了闭包
  - 通过chrome工具得知: 闭包本质是内部函数中的一个对象, 这个对象中包含引用的变量属性
- 作用:
  - 延长局部变量的生命周期
  - 让函数外部能操作内部的局部变量
- 写一个闭包程序
  ```
  function fn1() {
    var a = 2;
    function fn2() {
      a++;
      console.log(a);
    }
    return fn2;
  }
  var f = fn1();
  f();
  f();
  ```
- 闭包应用:
  - 模块化: 封装一些数据以及操作数据的函数, 向外暴露一些行为
  - 循环遍历加监听
  - JS框架(jQuery)大量使用了闭包
- 缺点:
  - 变量占用内存的时间可能会过长
  - 可能导致内存泄露
  - 解决:
    - 及时释放 : f = null; //让内部函数对象成为垃圾对象

#### 变量的声明提前 Variable Declare
- 变量的声明提前
  - 使用var关键字声明的变量，会在所有的代码执行之前被声明（但是不会赋值），
  - 但是如果声明变量时不适用var关键字，则变量不会被声明提前
  - Difference between var and let in JavaScript
    - The main difference between let and var is that scope of a variable defined with let is limited to the block in which it is declared while variable declared with var has the global scope. So we can say that var is rather a keyword which defines a variable globally regardless of block scope.
    - The scope of let not only limited to the block in which it is defined but variable with let also do not get added with global window object even if it get declared outside of any block. But we can access variable with var from window object if it is defined globally.
    - Due to limited scope let variables are usually used when there is limited use of those variables such as in for loops, while loops or inside the scope of if conditions etc while var variable is used when value of variable need to be less change and used to accessed globally.
    - Also, one difference between var and let is variable with var can be redeclared to some other value while variable could not be redeclared if it is defined with let.
- 函数的声明提前
  - 使用函数声明形式创建的函数 function 函数(){} 它会在所有的代码执行之前就被创建，所以我们可以在函数声明前来调用函数
    ```
    function fun(){
				console.log("我是一个fun函数");
		}
    ```
  - 使用函数表达式创建的函数，不会被声明提前，所以不能在声明前调用
    ```
    var fun2 = function(){
				console.log("我是fun2函数");
		};
    ```

#### 执行上下文与执行上下文栈 Context
- 变量提升与函数提升
  - 变量提升: 在变量定义语句之前, 就可以访问到这个变量(undefined)
  - 函数提升: 在函数定义语句之前, 就执行该函数
  - 先有变量提升, 再有函数提升
- 理解
  - 执行上下文: 由js引擎自动创建的对象, 包含对应作用域中的所有变量属性
  - 执行上下文栈: 用来管理产生的多个执行上下文
- 分类:
  - 全局: window
  - 函数: 对程序员来说是透明的
- 生命周期
  - 全局 : 准备执行全局代码前产生, 当页面刷新/关闭页面时死亡
  - 函数 : 调用函数时产生, 函数执行完时死亡
- 包含哪些属性:
  - 全局 : 
    - 用var定义的全局变量  ==>undefined
    - 使用function声明的函数   ===>function
    - this   ===>window
  - 函数
    - 用var定义的局部变量  ==>undefined
    - 使用function声明的函数   ===>function
    - this   ===> 调用函数的对象, 如果没有指定就是window 
    - 形参变量   ===>对应实参值
    - arguments ===>实参列表的伪数组
- 执行上下文创建和初始化的过程
  - 全局:
    - 在全局代码执行前最先创建一个全局执行上下文(window)
    - 收集一些全局变量, 并初始化
    - 将这些变量设置为window的属性
  - 函数:
    - 在调用函数时, 在执行函数体之前先创建一个函数执行上下文
    - 收集一些局部变量, 并初始化
    - 将这些变量设置为执行上下文的属性

#### 内存溢出与内存泄露
1. 内存溢出
  - 一种程序运行出现的错误
  - 当程序运行需要的内存超过了剩余的内存时, 就出抛出内存溢出的错误
2. 内存泄露
  - 占用的内存没有及时释放
  - 内存泄露积累多了就容易导致内存溢出
  - 常见的内存泄露:
    - 意外的全局变量
    - 没有及时清理的计时器或回调函数
    - 闭包

#### this
- 解析器在调用函数每次都会向函数内部传递进一个隐含的参数,
- 这个隐含的参数就是this，this指向的是一个对象，
- 这个对象我们称为函数执行的 上下文对象，
- 根据函数的调用方式的不同，this会指向不同的对象
  1. 以函数的形式调用时，this永远都是window
  2. 以方法的形式调用时，this就是调用方法的那个对象

#### 批量创建对象
##### 工厂方法创建对象
- 通过该方法可以大批量的创建对象
  ```
  function createPerson(name , age ,gender){
    //创建一个新的对象 
		var obj = new Object();
		//向对象中添加属性
		obj.name = name;
		obj.age = age;
		obj.gender = gender;
		obj.sayName = function(){
			alert(this.name);
		};
		//将新的对象返回
		return obj;
	}
  var obj2 = createPerson("猪八戒",28,"男");
	var obj3 = createPerson("白骨精",16,"女");
	var obj4 = createPerson("蜘蛛精",18,"女");
  ```
- 使用工厂方法创建的对象，使用的构造函数都是Object
  - 所以创建的对象都是Object这个类型，
  - 就导致我们无法区分出多种不同类型的对象

##### 构造函数方法
- 创建一个构造函数，专门用来创建对象的
  - 构造函数就是一个普通的函数，创建方式和普通函数没有区别,
  - 不同的是构造函数习惯上首字母大写
- 构造函数和普通函数的区别就是调用方式的不同
  - 普通函数是直接调用，而构造函数需要使用new关键字来调用
- 构造函数的执行流程：
  1. 立刻创建一个新的对象
  2. 将新建的对象设置为函数中this,在构造函数中可以使用this来引用新建的对象
  3. 逐行执行函数中的代码
  4. 将新建的对象作为返回值返回
- 使用同一个构造函数创建的对象，我们称为一类对象，也将一个构造函数称为一个类。
  - 我们将通过一个构造函数创建的对象，称为是该类的实例
- this的情况：
  1. 当以函数的形式调用时，this是window
  2. 当以方法的形式调用时，谁调用方法this就是谁
  3. 当以构造函数的形式调用时，this就是新创建的那个对象

#### 原型与原型链 prototype
- 我们所创建的每一个函数，解析器Interpreter都会向函数中添加一个属性prototype,这个属性对应着一个对象，这个对象就是我们所谓的原型对象
- 如果函数作为普通函数调用prototype没有任何作用
- 当函数以构造函数的形式调用时，它所创建的对象中都会有一个隐含的属性,指向该构造函数的原型对象，我们可以通过__proto__来访问该属性
- 原型对象就相当于一个公共的区域，所有同一个类的实例都可以访问到这个原型对象，我们可以将对象中共有的内容，统一设置到原型对象中。
- 当我们访问对象的一个属性或方法时，它会先在对象自身中寻找，如果有则直接使用，如果没有则会去原型对象中寻找，如果找到则直接使用
- 以后我们创建构造函数时，可以将这些对象共有的属性和方法，统一添加到构造函数的原型对象中，这样不用分别为每一个对象添加，也不会影响到全局作用域，就可以使每个对象都具有这些属性和方法了
- 原型对象也是对象，所以它也有原型，当我们使用一个对象的属性或方法时，会现在自身中寻找，
  - 自身中如果有，则直接使用，
  - 如果没有则去原型对象中寻找，如果原型对象中有，则使用，
  - 如果没有则去原型的原型中寻找,直到找到Object对象的原型，
  - Object对象的原型没有原型，如果在Object原型中依然没有找到，则返回undefined
- 使用in检查对象中是否含有某个属性时，如果对象中没有但是原型中有，也会返回true `console.log("name" in mc)`
- 可以使用对象的hasOwnProperty()来检查对象自身中是否含有该属性
  - 使用该方法只有当对象自身中含有属性时，才会返回true
  - `console.log(mc.hasOwnProperty("age"))`
- 总结
  - 所有函数都有一个特别的属性:
    - `prototype` : 显式原型属性
  - 所有实例对象都有一个特别的属性:
    - `__proto__` : 隐式原型属性
  - 显式原型与隐式原型的关系
    - 函数的prototype: 定义函数时被自动赋值, 值默认为{}, 即用为原型对象
    - 实例对象的__proto__: 在创建实例对象时被自动添加, 并赋值为构造函数的prototype值
    - 原型对象即为当前实例对象的父对象
  - 原型链
    - 所有的实例对象都有__proto__属性, 它指向的就是原型对象
    - 这样通过__proto__属性就形成了一个链的结构---->原型链
    - 当查找对象内部的属性/方法时, js引擎自动沿着这个原型链查找
    - 当给对象属性赋值时不会使用原型链, 而只是在当前对象中进行操作

#### 垃圾回收 GC
- 程序运行过程中也会产生垃圾，这些垃圾积攒过多以后，会导致程序运行的速度过慢，所以我们需要一个垃圾回收的机制，来处理程序运行过程中产生垃圾
- 当一个对象没有任何的变量或属性对它进行引用，此时我们将永远无法操作该对象，此时这种对象就是一个垃圾，这种对象过多会占用大量的内存空间，导致程序运行变慢，所以这种垃圾必须进行清理。
- 在JS中拥有自动的垃圾回收机制，会自动将这些垃圾对象从内存中销毁，我们不需要也不能进行垃圾回收的操作
- 我们需要做的只是要将不再使用的对象设置null即可`var obj = new Object();`

#### 数组 Array
- 数组也是一个对象
- 它和我们普通对象功能类似，也是用来存储一些值的
- 不同的是普通对象是使用字符串作为属性名的，而数组时使用数字来作为索引操作元素
- 索引 index：从0开始的整数就是索引
- 数组的存储性能比普通对象要好，在开发中我们经常使用数组来存储一些数据
- 使用typeof检查一个数组时，会返回object
- 创建数组对象 
  - 构造函数创建
    - `var arr = new Array();`
    - 使用构造函数创建数组时，也可以同时添加元素，将要添加的元素作文构造函数的参数传递
    - 元素之间使用,隔开`var arr = new Array(10,20,30);`
    - 创建一个数组数组中只有一个元素10 `var arr = [10];`
    - 创建一个长度为10的数组`arr = new Array(10);`
  - 字面量创建
    - 使用字面量来创建数组,语法:[] `var arr = [];`
    - 使用字面量创建数组时，可以在创建时就指定数组中的元素 `var arr = [1,2,3,4,5,10];`
- 向数组中添加元素,语法：数组[索引] = 值 `arr[0] = 10;`
- 读取数组中的元素,语法：数组[索引]
  - 如果读取不存在的索引，他不会报错而是返回undefined
- 获取数组的长度
  - 可以使用length属性来获取数组的长度(元素的个数)
  - 语法：数组.length
  - 对于连续的数组，使用length可以获取到数组的长度（元素的个数）
  - 对于非连续的数组，使用length会获取到数组的最大的索引+1 (量不要创建非连续的数组)
  - 修改length `arr.length = 10;`
    - 如果修改的length大于原长度，则多出部分会空出来
    - 如果修改的length小于原长度，则多出的元素会被删除
- 向数组的最后一个位置添加元素,语法：数组[数组.length] = 值;
- 数组中的元素可以是任意的数据类型
  - 也可以是对象
  - 也可以是一个函数
  - 数组中也可以放数组，如下这种数组我们称为二维数组 `arr = [[1,2,3],[3,4,5],[5,6,7]];`

#### 数组的方法
- 遍历 Traversal
  - 所谓的遍历数组，就是将数组中所有的元素都取出来
  - for循环去遍历数组
    ```
    for(var i=0 ; i<arr.length ; i++){
				console.log(arr[i]);
		}
    ```
  - forEach()
    - 这个方法只支持IE8以上的浏览器
    - forEach()方法需要一个函数作为参数
    - 像这种函数，由我们创建但是不由我们调用的，我们称为回调函数
    - 数组中有几个元素函数就会执行几次，每次执行时，浏览器会将遍历到的元素
      - 以实参的形式传递进来，我们可以来定义形参，来读取这些内容
    - 浏览器会在回调函数中传递三个参数：
      - 第一个参数，就是当前正在遍历的元素
      - 第二个参数，就是当前正在遍历的元素的索引
      - 第三个参数，就是正在遍历的数组
        ```
        arr.forEach(function(value , index , obj){
				console.log(value);
			  });
        ```
- push()
  - 该方法可以向数组的末尾添加一个或多个元素，并返回数组的新的长度
  - 可以将要添加的元素作为方法的参数传递，这样这些元素将会自动添加到数组的末尾
  - 该方法会将数组新的长度作为返回值返回
- pop()
  - 该方法可以删除数组的最后一个元素,并将被删除的元素作为返回值返回
- unshift()
  - 向数组开头添加一个或多个元素，并返回新的数组长度
  - 向前边插入元素以后，其他的元素索引会依次调整
- shift()
  - 可以删除数组的第一个元素，并将被删除的元素作为返回值返回
- slice()
  - 可以用来从数组提取指定元素
  - 该方法不会改变元素数组，而是将截取到的元素封装到一个新数组中返回
  - 参数：
    1. 截取开始的位置的索引,包含开始索引
    2. 截取结束的位置的索引,不包含结束索引
  - 第二个参数可以省略不写,此时会截取从开始索引往后的所有元素
  - 索引可以传递一个负值，如果传递一个负值，则从后往前计算
    - `-1` 倒数第一个
		- `-2` 倒数第二个
- splice()
  - 可以用于删除数组中的指定元素
  - 使用splice()会影响到原数组，会将指定元素从原数组中删除,并将被删除的元素作为返回值返回
  - 参数：
    - 第一个，表示开始位置的索引
    - 第二个，表示删除的数量
    - 第三个及以后, 可以传递一些新的元素，这些元素将会自动插入到开始位置索引前边
- concat()
  - 可以连接两个或多个数组，并将新的数组返回
  - 该方法不会对原数组产生影响
- join()
  - 该方法可以将数组转换为一个字符串
  - 该方法不会对原数组产生影响，而是将转换后的字符串作为结果返回
  - 在join()中可以指定一个字符串作为参数，这个字符串将会成为数组中元素的连接符
    - 如果不指定连接符，则默认使用,作为连接符
- reverse()
  - 该方法用来反转数组（前边的去后边，后边的去前边）
  - 该方法会直接修改原数组
- sort()
  - 可以用来对数组中的元素进行排序
  - 也会影响原数组，默认会按照Unicode编码进行排序
  - 即使对于纯数字的数组，使用sort()排序时，也会按照Unicode编码来排序，所以对数字进排序时，可能会得到错误的结果。
  - 我们可以在sort()添加一个回调函数，来指定排序规则，
    - 回调函数中需要定义两个形参,
    - 浏览器将会分别使用数组中的元素作为实参去调用回调函数
    - 使用哪个元素调用不确定，但是肯定的是在数组中a一定在b前边
    - 浏览器会根据回调函数的返回值来决定元素的顺序，
      - 如果返回一个大于0的值，则元素会交换位置
      - 如果返回一个小于0的值，则元素位置不变
      - 如果返回一个0，则认为两个元素相等，也不交换位置
    - 如果需要升序排列，则返回 a-b
    - 如果需要降序排列，则返回 b-a
      ```
      arr = [5,4,2,1,3,6,8,7];
      arr.sort(function(a,b){
				//前边的大
				/*if(a > b){
					return -1;
				}else if(a < b){
					return 1;
				}else{
					return 0;
				}*/
				//升序排列
				//return a - b;
				//降序排列
				return b - a;
		  });
      ```

#### call() & apply()
- 这两个方法都是函数对象的方法，需要通过函数对象来调用
- 当对函数调用call()和apply()都会调用函数执行
- 在调用call()和apply()可以将一个对象指定为第一个参数，此时这个对象将会成为函数执行时的this
- call()方法可以将实参在对象之后依次传递
- apply()方法需要将实参封装到一个数组中统一传递
- this的情况：
  1. 以函数形式调用时，this永远都是window
  2. 以方法的形式调用时，this是调用方法的对象
  3. 以构造函数的形式调用时，this是新创建的那个对象
  4. 使用call和apply调用时，this是指定的那个对象

#### arguments
- 在调用函数时，浏览器每次都会传递进两个隐含的参数：
  1. 函数的上下文对象 this
  2. 封装实参的对象 arguments
     - arguments是一个类数组对象,它也可以通过索引来操作数据，也可以获取长度
     - 在调用函数时，我们所传递的实参都会在arguments中保存
     - arguments.length可以用来获取实参的长度
     - 我们即使不定义形参，也可以通过arguments来使用实参，只不过比较麻烦
       - arguments[0] 表示第一个实参
       - arguments[1] 表示第二个实参
     - 它里边有一个属性叫做callee,这个属性对应一个函数对象，就是当前正在指向的函数的对象

#### Date
- 在JS中使用Date对象来表示一个时间
- 创建一个Date对象
  - 如果直接使用构造函数创建一个Date对象，则会封装为当前代码执行的时间
- 创建一个指定的时间对象
  - 需要在构造函数中传递一个表示时间的字符串作为参数
  - 日期的格式  月份/日/年 时:分:秒
- getDate() 
  - 获取当前日期对象是几日
- getDay()
  - 获取当前日期对象时周几
  - 会返回一个0-6的值
    - 0 表示周日
    - 1 表示周一
- getMonth()
  - 获取当前时间对象的月份
  - 会返回一个0-11的值
    - 0 表示1月
    - 1 表示2月
    - 11 表示12月
- getFullYear()
  - 获取当前日期对象的年份
- getTime()
  - 获取当前日期对象的时间戳
  - 时间戳，指的是从格林威治标准时间的1970年1月1日，0时0分0秒,到当前日期所花费的毫秒数（1秒 = 1000毫秒）
  - 计算机底层在保存时间时使用都是时间戳
- 利用时间戳来测试代码的执行的性能
  - 获取当前的时间戳
    ```
    var start = Date.now();	
	  for(var i=0 ; i<100 ; i++){
	  	console.log(i);
	  }
	  var end = Date.now();
	  console.log("执行了："+(end - start)+"毫秒");
    ```

#### Math
- Math和其他的对象不同，它不是一个构造函数，它属于一个工具类不用创建对象，它里边封装了数学运算相关的属性和方法
- Math.PI 
  - 表示的圆周率
- Math.abs() 
  - 可以用来计算一个数的绝对值
- Math.ceil()
  - 可以对一个数进行向上取整，小数位只有有值就自动进1
- Math.floor()
  - 可以对一个数进行向下取整，小数部分会被舍掉
- Math.round()
  - 可以对一个数进行四舍五入取整
- Math.random()
  - 可以用来生成一个0-1之间的随机数
  - 生成一个0-10的随机数
  - 生成一个0-x之间的随机数`Math.round(Math.random()*x)`
  - 生成一个x-y之间的随机数`Math.round(Math.random()*(y-x)+x)`
- max() 
  - 可以获取多个数中的最大值
- min() 
  - 可以获取多个数中的最小值
- Math.pow(x,y)
  - 返回x的y次幂
- Math.sqrt()
  - 用于对一个数进行开方运算

#### 包装类 Wrapper Class
- 在JS中为我们提供了三个包装类，通过这三个包装类可以将基本数据类型的数据转换为对象
  - String() 可以将基本数据类型字符串转换为String对象
  - Number() 可以将基本数据类型的数字转换为Number对象
  - Boolean() 可以将基本数据类型的布尔值转换为Boolean对象
- 但是注意：我们在实际应用中不会使用基本数据类型的对象，如果使用基本数据类型的对象，在做一些比较时可能会带来一些不可预期的结果.
- 方法和属性之能添加给对象，不能添加给基本数据类型
- 当我们对一些基本数据类型的值去调用属性和方法时，浏览器会临时使用包装类将其转换为对象，然后在调用对象的属性和方法，调用完以后，在将其转换为基本数据类型

#### 字符串相关方法 String
- 在底层字符串是以字符数组的形式保存的`["H","e","l"]`
- length
  - 可以用来获取字符串的长度`console.log(str.length);`,`console.log(str[5]);`
- charAt()
  - 可以返回字符串中指定位置的字符,根据索引获取指定的字符	
  ```
  str = "中Hello Atguigu";
  var result = str.charAt(6);
  var result = str[6];
  ```
- charCodeAt()
  - 获取指定位置字符的字符编码（Unicode编码）
  ```
  result = str.charCodeAt(0);
  ```
- String.formCharCode()
  - 可以根据字符编码去获取字符
  ```
  result = String.fromCharCode(0x2692);
  ```
- concat()
  - 可以用来连接两个或多个字符串,作用和+一样
  ```
  result = str.concat("你好", "再见");
  ```
- indexof()
  - 该方法可以检索一个字符串中是否含有指定内容
  - 如果字符串中含有该内容，则会返回其第一次出现的索引，如果没有找到指定的内容，则返回-1
  - 可以指定一个第二个参数，指定开始查找的位置
  ```
  str = "hello hatguigu";
  result = str.indexOf("h", 1);
  ```
- lastIndexOf()
  - 该方法的用法和indexOf()一样，不同的是indexOf是从前往后找，而lastIndexOf是从后往前找
  - 也可以指定开始查找的位置
  ```
  result = str.lastIndexOf("h", 5);
  ```
- slice()
  - 可以从字符串中截取指定的内容
  - 不会影响原字符串，而是将截取到内容返回
  - 参数：
    - 第一个，开始位置的索引（包括开始位置）
    - 第二个，结束位置的索引（不包括结束位置）
    - 如果省略第二个参数，则会截取到后边所有的
    - 也可以传递一个负数作为参数，负数的话将会从后边计算
  ```
  str = "abcdefghijk";
  result = str.slice(1, 4);
  result = str.slice(1, -1);
  ```
- substring()
  - 可以用来截取一个字符串，和slice()类似
  - 参数：
    - 第一个，开始截取位置的索引（包括开始位置）
    - 第二个，结束位置的索引（不包括结束位置）
    - 不同的是这个方法不能接受负值作为参数，如果传递了一个负值，则默认使用0
    - 而且他还自动调整参数的位置，如果第二个参数小于第一个，则自动交换
  ```
  result = str.substring(0, 1);
  ```
- substr()
  - 用来截取字符串
  - 参数：
    - 第一个，截取开始位置的索引
    - 第二个，截取的长度
  ```
  str = "abcdefg";
  result = str.substr(3, 2);
  ```
- split()
  - 可以将一个字符串拆分为一个数组
  - 需要一个字符串作为参数，将会根据该字符串去拆分数组
  ```
  str = "abcbcdefghij";
  result = str.split("d");
  ```
  - 如果传递一个空串作为参数，则会将每个字符都拆分为数组中的一个元素
- toUpperCase()
  - 将一个字符串转换为大写并返回
- toLowerCase()
  - 将一个字符串转换为小写并返回

#### 正则表达式 Regular expression
- 正则表达式用于定义一些字符串的规则，计算机可以根据正则表达式，来检查一个字符串是否符合规则，或者将字符串中符合规则的内容提取出来
- 创建正则表达式的对象
  - 语法：var 变量 = new RegExp("正则表达式","匹配模式");
  - 使用typeof检查正则对象，会返回object
  - var reg = new RegExp("a"); 这个正则表达式可以来检查一个字符串中是否含有a
  - 在构造函数中可以传递一个匹配模式作为第二个参数，
    - i ignor忽略大小写 
    - g global全局匹配模式
- 正则表达式的方法：
  - test()
    - 使用这个方法可以用来检查一个字符串是否符合正则表达式的规则，
    - 如果符合则返回true，否则返回false
    ```
    var reg = new RegExp("ab", "i");
    var str = "a";
    var result = reg.test(str);
    console.log(reg.test("Ac"));
    ```
- 使用字面量来创建正则表达式
  - 语法：var 变量 = /正则表达式/匹配模式 `var reg = /a/i;`
  - 使用字面量的方式创建更加简单
  - 使用构造函数创建更加灵活
  - 创建一个正则表达式，检查一个字符串中是否有a或b `reg = /a|b|c/;`
  - 创建一个正则表达式检查一个字符串中是否有字母 `//reg = /a|b|c|d|e|f|g/`
  - []里的内容也是或的关系`reg = /[A-z]/;`
    - `[ab]` == a|b
    - `[a-z]` 任意小写字母
    - `[A-Z]` 任意大写字母
    - `[A-z]` 任意字母
    - `[0-9]` 任意数字
  - 检查一个字符串中是否含有 abc 或 adc 或 aec `reg = /a[bde]c/;`
  - `[^ ]` 除了`reg = /[^ab]/;`,`reg = /[^0-9]/;`
- 字符串和正则相关的方法 `var str = "1a2b3c4d5e6f7";`
  - split()
    - 可以将一个字符串拆分为一个数组
    - 方法中可以传递一个正则表达式作为参数，这样方法将会根据正则表达式去拆分字符串
    - 这个方法即使不指定全局匹配，也会全都拆分
      - 根据任意字母来将字符串拆分 `var result = str.split(/[A-z]/);`
  - search()
    - 可以搜索字符串中是否含有指定内容
    - 如果搜索到指定内容，则会返回第一次出现的索引，如果没有搜索到返回-1
    - 它可以接受一个正则表达式作为参数，然后会根据正则表达式去检索字符串
    - serach()只会查找第一个，即使设置全局匹配也没用
    - 搜索字符串中是否含有abc 或 aec 或 afc
      ```
      str = "hello abc hello aec afc";
      result = str.search(/a[bef]c/);
      ```
  - match()
    - 可以根据正则表达式，从一个字符串中将符合条件的内容提取出来
    - 默认情况下我们的match只会找到第一个符合要求的内容，找到以后就停止检索
      - 我们可以设置正则表达式为全局匹配模式，这样就会匹配到所有的内容
      - 可以为一个正则表达式设置多个匹配模式，且顺序无所谓
    - match()会将匹配到的内容封装到一个数组中返回，即使只查询到一个结果
    ```
    str = "1a2a3a4a5e6f7A8B9C";
    result = str.match(/[a-z]/ig);
    ```
  - replace()
    - 可以将字符串中指定内容替换为新的内容
    - 参数：
      1. 被替换的内容，可以接受一个正则表达式作为参数
      2. 新的内容
    - 默认只会替换第一个
    ```
    result = str.replace(/[a-z]/gi , "");
    ```
- 正则语法
  - 量词 {}
    - 通过量词可以设置一个内容出现的次数
    - 量词只对它前边的一个内容起作用
    - {n} 正好出现n次 `var reg = /a{3}/;`,`reg = /(ab){3}/;`
    - {m,n} 出现m-n次 `reg = /ab{1,3}c/;`
    - {m,} m次以上 `reg = /ab{3,}c/;`
    - `+` 至少一个，相当于{1,} `reg = /ab+c/;`
    - `*` 0个或多个，相当于{0,} `reg = /ab*c/;`
    - `?` 0个或1个，相当于{0,1} `reg = /ab?c/;`
  - 头尾 ^ $
    - ^ 表示开头 `reg = /^a/; //匹配开头的a`
    - $ 表示结尾 `reg = /a$/; //匹配结尾的a`
    - 如果在正则表达式中同时使用`^ $`则要求字符串必须完全符合正则表达式`reg = /^a$/;`
  - 转义 \
    - 检查一个字符串中是否含有 `.`，`.` 表示任意字符
    - 在正则表达式中使用\作为转义字符
    - `\.` 来表示.,`\\` 表示\
    - 注意：使用构造函数时，由于它的参数是一个字符串，而\是字符串中转义字符，如果要使用\则需要使用`\\`来代替
  - 除了 w d s b
    - \w 任意字母、数字、_  `[A-z0-9_]`
    - \W 除了字母、数字、_  `[^A-z0-9_]`
    - \d 任意的数字 `[0-9]`
    - \D 除了数字 `[^0-9]`
    - \s 空格
    - \S 除了空格
    - \b 单词边界,创建一个正则表达式检查一个字符串中是否含有单词child `reg = /\bchild\b/;`
    - \B 除了单词边界

### DOM Document Object Model
#### DOM
- 文档对象模型，通过DOM可以来任意来修改网页中各个内容
- 文档
	- 文档指的是网页，一个网页就是一个文档
- 对象
	- 对象指将网页中的每一个节点都转换为对象
	- 转换完对象以后，就可以以一种纯面向对象的形式来操作网页了
- 模型
	- 模型用来表示节点和节点之间的关系，方便操作页面
- 节点（Node）
	- 节点是构成网页的最基本的单元，网页中的每一个部分都可以称为是一个节点
	- 虽然都是节点，但是节点的类型却是不同的
	- 常用的节点
		- 文档节点 （Document），代表整个网页
		- 元素节点（Element），代表网页中的标签
		- 属性节点（Attribute），代表标签中的属性
		- 文本节点（Text），代表网页中的文本内容

#### DOM操作
- 在网页中浏览器已经为我们提供了document对象，它代表的是整个网页，它是window对象的属性，可以在页面中直接使用。
- DOM查询方法：
	- 根据元素的id属性查询一个元素节点对象：
		- document.getElementById("id属性值");
	- 根据元素的name属性值查询一组元素节点对象:
		- document.getElementsByName("name属性值");
	- 根据标签名来查询一组元素节点对象：
		- document.getElementsByTagName("标签名");
    - 这个方法会给我们返回一个类数组对象，所有查询到的元素都会封装到对象中
    - 即使查询到的元素只有一个，也会封装到数组中返回
    ```
    var lis = document.getElementsByTagName("li");
    for(var i=0 ; i<lis.length ; i++){
		  alert(lis[i].innerHTML);
		  }
    };
    ```
- DOM对象的其他的属性和方法
  - document.body 
    - 获取body标签 `var body = document.getElementsByTagName("body")[0];`
  - document.documentElement
    - 获取页面中html根元素 `var html = document.documentElement;`
  - document.all
    - 获取页面中的所有元素，相当于`document.getElementsByTagName("*");`
  - getElementsByClassName()
    - 可以根据class属性值获取一组元素节点对象，
    - 但是该方法不支持IE8及以下的浏览器
  - document.querySelector()
    - 需要一个选择器的字符串作为参数，可以根据一个CSS选择器来查询一个元素节点对象 `var div = document.querySelector(".box1 div");`
    - 虽然IE8中没有getElementsByClassName()但是可以使用querySelector()代替
    - 使用该方法总会返回唯一的一个元素，如果满足条件的元素有多个，那么它只会返回第一个
  - document.querySelectorAll()
    - 该方法和querySelector()用法类似，不同的是它会将符合条件的元素封装到一个数组中返回
    - 即使符合条件的元素只有一个，它也会返回数组
- 通过具体的元素节点来查询
	- 元素.getElementsByTagName()
		- 通过标签名查询当前元素的指定后代元素
	- 元素.childNodes
		- 获取当前元素的所有子节点
		- 会获取到空白的文本子节点
	- 元素.children
		- 获取当前元素的所有子元素
	- 元素.firstChild
		- 获取当前元素的第一个子节点
	- 元素.lastChild
		- 获取当前元素的最后一个子节点
	- 元素.parentNode
		- 获取当前元素的父元素
	- 元素.previousSibling
		- 获取当前元素的前一个兄弟节点
	- 元素.nextSibling
		- 获取当前元素的后一个兄弟节点
- 元素的属性：
	- 读取元素的属性：
	- 语法：元素.属性名
	- 例子：
    - ele.name
    - ele.id  
    - ele.value 
    - ele.className	
  - 注意：class属性不能采用这种方式，读取class属性时需要使用 元素.className	  
	- 修改元素的属性：语法：元素.属性名 = 属性值
	- innerHTML 和 innerText
		- 使用该属性可以获取或设置元素内部的HTML代码
		- 对于自结束标签，这个属性没有意义
		- 这两个属性并没有在DOM标准定义，但是大部分浏览器都支持这两个属性
		- 两个属性作用类似，都可以获取到标签内部的内容，不同是innerHTML会获取到html标签，而innerText会自动去除标签
		- 如果使用这两个属性来设置标签内部的内容时，没有任何区别的	
- DOM修改
  - document.createElement()
    - 可以根据标签名创建一个元素节点对象
  - document.createTextNode()
    - 可以根据文本内容创建一个文本节点对象
  - 父节点.appendChild(子节点)
    - 向父节点中添加指定的子节点
  - 父节点.insertBefore(新节点,旧节点)
    - 将一个新的节点插入到旧节点的前边
  - 父节点.replaceChild(新节点,旧节点)
    - 使用一个新的节点去替换旧节点
  - 父节点.removeChild(子节点)
    - 删除指定的子节点
    - 推荐方式：子节点.parentNode.removeChild(子节点)

#### DOM对CSS的操作
- 读取和修改内联样式
  - 使用style属性来操作元素的内联样式
  - 读取内联样式：
    - 语法：元素.style.样式名
    - 例子：
      - 元素.style.width
      - 元素.style.height
    - 注意：如果样式名中带有-，则需要将样式名修改为驼峰命名法将-去掉，然后-后的字母改大写
    - 比如：background-color --> backgroundColor, border-width ---> borderWidth
  - 修改内联样式：
    - 语法：元素.style.样式名 = 样式值
    - 通过style修改的样式都是内联样式，由于内联样式的优先级比较高，所以我们通过JS来修改的样式，往往会立即生效，所以我们通过JS来修改的样式，往往会立即生效。
- 读取元素的当前样式
  - 正常浏览器
    - 使用getComputedStyle()
    - 这个方法是window对象的方法，可以返回一个对象，这个对象中保存着当前元素生效样式
    - 参数：
      1. 要获取样式的元素
      2. 可以传递一个伪元素，一般传null
    - 例子：获取元素的宽度`getComputedStyle(box , null)["width"];`
    - 通过该方法读取到样式都是只读的不能修改
  - IE8
    - 使用currentStyle
    - 语法：元素.currentStyle.样式名
    - 例子：`box.currentStyle["width"]`
    - 通过这个属性读取到的样式是只读的不能修改
- 其他的样式相关的属性(只读)
  - clientHeight
  	- 元素的可见高度，指元素的内容区和内边距的高度
  - clientWidth
  	- 元素的可见宽度，指元素的内容区和内边距的宽度
  - offsetHeight
  	- 整个元素的高度，包括内容区、内边距、边框
  - offfsetWidth
  	- 整个元素的宽度，包括内容区、内边距、边框
  - offsetParent
  	- 当前元素的定位父元素
  	- 离他最近的开启了定位的祖先元素，如果所有的元素都没有开启定位，则返回body
  - offsetLeft
  - offsetTop
  	- 当前元素和定位父元素之间的偏移量
  	- offsetLeft水平偏移量  offsetTop垂直偏移量
  - scrollHeight
  - scrollWidth
  	- 获取元素滚动区域的高度和宽度
  - scrollTop
  - scrollLeft
  	- 获取元素垂直和水平滚动条滚动的距离
  - 判断滚动条是否滚动到底
  	- 垂直滚动条 `scrollHeight - scrollTop = clientHeight`		
  	- 水平滚动  `scrollWidth - scrollLeft = clientWidth`

#### 事件 Event
- 当响应函数被调用时，浏览器每次都会将一个事件对象作为实参传递进响应函数中，
- 事件指的是用户和浏览器之间的交互行为。比如：点击按钮、关闭窗口、鼠标移动。。。
- 我们可以为事件来绑定回调函数来响应事件。
- 绑定事件的方式：
	1. 可以在标签的事件属性中设置相应的JS代码
		- 例子：`<button onclick="js代码。。。">按钮</button>`
	2. 可以通过为对象的指定事件属性设置回调函数的形式来处理事件
		- 例子：
      ```
			<button id="btn">按钮</button>
			<script>
				var btn = document.getElementById("btn");
				btn.onclick = function(){
				};
			</script>
      ```
- 事件的冒泡 Bubble
  - 事件的冒泡指的是事件向上传导，当后代元素上的事件被触发时，将会导致其祖先元素上的同类事件也会触发。
  - 事件的冒泡大部分情况下都是有益的，如果需要取消冒泡，则需要使用事件对象来取消
  - 可以将事件对象的cancelBubble设置为true，即可取消冒泡
  - 例子：
    ```
    元素.事件 = function(event){
		  event = event || window.event;
			event.cancelBubble = true;
		};
    ```

#### 文档的加载 onload
- 浏览器在加载一个页面时，是按照自上向下的顺序加载的，加载一行执行一行。
- 如果将js代码编写到页面的上边，当代码执行时，页面中的DOM对象还没有加载，此时将会无法正常获取到DOM对象，导致DOM操作失败。
- 解决方式一：
	- 可以将js代码编写到body的下边
  ```
	<body>
		<button id="btn">按钮</button>
		<script>
			var btn = document.getElementById("btn");
			btn.onclick = function(){	
			};
		</script>
	</body>
  ```
- 解决方式二：
	- 将js代码编写到window.onload = function(){}中
	- window.onload 对应的回调函数会在整个页面加载完毕以后才执行，所以可以确保代码执行时，DOM对象已经加载完毕了
  ```
	<script>
		window.onload = function(){
			var btn = document.getElementById("btn");
			btn.onclick = function(){	
			};
		};
	</script>
  ```

### BOM Browser Object Model
- BOM可以使我们通过JS来操作浏览器
- 在BOM中为我们提供了一组对象，用来完成对浏览器的操作
- 这些BOM对象在浏览器中都是作为window对象的属性保存的，可以通过window对象来使用，也可以直接使用
  - Window 
    - 代表的是整个浏览器的窗口，同时window也是网页中的全局对象
  - Navigator 
    - 代表的当前浏览器的信息，通过该对象可以来识别不同的浏览器
  - Location 
    - 代表当前浏览器的地址栏信息，通过Location可以获取地址栏信息，或者操作浏览器跳转页面
  - History
    - 代表浏览器的历史记录，可以通过该对象来操作浏览器的历史记录
    - 由于隐私原因，该对象不能获取到具体的历史记录，只能操作浏览器向前或向后翻页
    - 而且该操作只在当次访问时有效
  - Screen
    - 代表用户的屏幕的信息，通过该对象可以获取到用户的显示器的相关的信息
- Navigator 
  - 代表的当前浏览器的信息，通过该对象可以来识别不同的浏览器
  - 由于历史原因，Navigator对象中的大部分属性都已经不能帮助我们识别浏览器了
  - 一般我们只会使用userAgent来判断浏览器的信息，userAgent是一个字符串，这个字符串中包含有用来描述浏览器信息的内容，不同的浏览器会有不同的userAgent
  - 如果通过UserAgent不能判断，还可以通过一些浏览器中特有的对象，来判断浏览器的信息，比如：ActiveXObject
  ```
  if("ActiveXObject" in window){
		alert("你是IE，我已经抓住你了~~~");
		}else{
			alert("你不是IE~~~");
		}
  ```
  ```
  alert("ActiveXObject" in window);
  ```
- History
  - 对象可以用来操作浏览器向前或向后翻页
  - length
    - 属性，可以获取到当成访问的链接数量 `alert(history.length)`
  - back()
    - 可以用来回退到上一个页面，作用和浏览器的回退按钮一样 `history.back();`
  - forward()
    - 可以跳转下一个页面，作用和浏览器的前进按钮一样 `history.forward();`
  - go()
    - 可以用来跳转到指定的页面
    - 它需要一个整数作为参数
      - `1`:表示向前跳转一个页面 相当于forward()
      - `2`:表示向前跳转两个页面
      - `-1`:表示向后跳转一个页面
      - `-2`:表示向后跳转两个页面
- Location
  - 该对象中封装了浏览器的地址栏的信息
  - 如果直接打印location，则可以获取到地址栏的信息（当前页面的完整路径）
  - 如果直接将location属性修改为一个完整的路径，或相对路径，则我们页面会自动跳转到该路径，并且会生成相应的历史记录
  - assign()
    - 用来跳转到其他的页面，作用和直接修改location一样
  - reload()
    - 用于重新加载当前页面，作用和刷新按钮一样
    - 如果在方法中传递一个true，作为参数，则会强制清空缓存刷新页面
  - replace()
    - 可以使用一个新的页面替换当前页面，调用完毕也会跳转页面
    - 不会生成历史记录，不能使用回退按钮回退

### 定时调用 setInterval()
- 可以将一个函数，每隔一段时间执行一次
- 参数：
  1. 回调函数，该函数会每隔一段时间被调用一次
  2. 每次调用间隔的时间，单位是毫秒
- 返回值：
  - 返回一个Number类型的数据
  - 这个数字用来作为定时器的唯一标识
- clearInterval()可以用来关闭一个定时器
  - 方法中需要一个定时器的标识作为参数，这样将关闭标识对应的定时器
  - clearInterval(timer);
```
var timer = setInterval(function(){				
	count.innerHTML = num++;
		if(num == 11){
      clearInterval(timer);//关闭定时器
		}
```

### 延时调用 setTimeout()
- 延时调用一个函数不马上执行，而是隔一段时间以后在执行，而且只会执行一次
- 延时调用和定时调用的区别，定时调用会执行多次，而延时调用只会执行一次
- 延时调用和定时调用实际上是可以互相代替的，在开发中可以根据自己需要去选择
```
var timer = setTimeout(function(){
	console.log(num++);
},3000);
clearTimeout(timer);//使用clearTimeout()来关闭一个延时调用
```

## JSON
- JSON (JavaScript Object Notation) 是一种轻量级的数据交换格式，来源于 JavaScript 同时也被多种语言所使用。 JSON 用于构建通用的数据结构。
- JS中的对象只有JS自己认识，其他的语言都不认识
- JSON就是一个特殊格式的字符串，这个字符串可以被任意的语言所识别，并且可以转换为任意语言中的对象，JSON在开发中主要用来数据的交互
- JavaScript Object Notation JS对象表示法
- JSON和JS对象的格式一样，只不过JSON字符串中的属性名必须加双引号,其他的和JS语法一致
- JSON这个对象在IE7及以下的浏览器中不支持，所以在这些浏览器中调用时会报错
- JSON分类：
  1. 对象 {}
  2. 数组 []
- JSON中允许的值：
  1. 字符串
  2. 数值
  3. 布尔值
  4. null
  5. 对象
  6. 数组
- 将JSON字符串转换为JS中的对象 
  - 在JS中，为我们提供了一个工具类，就叫JSON
  - 这个对象可以帮助我们将一个JSON转换为JS对象，也可以将一个JS对象转换为JSON
  - json --> js对象
    - JSON.parse()
    - 可以将以JSON字符串转换为js对象
    - 它需要一个JSON字符串作为参数，会将该字符串转换为JS对象并返回
  - JS对象 ---> JSON
    - JSON.stringify()
    - 可以将一个JS对象转换为JSON字符串
    - 需要一个js对象作为参数，会返回一个JSON字符串
- eval()
  - 这个函数可以用来执行一段字符串形式的JS代码，并将执行结果返回
  - 如果使用eval()执行的字符串中含有{},它会将{}当成是代码块
  - 如果不希望将其当成代码块解析，则需要在字符串前后各加一个()
  - eval()这个函数的功能很强大，可以直接执行一个字符串中的js代码，但是在开发中尽量不要使用，首先它的执行性能比较差，然后它还具有安全隐患
  ```
  var str2 = "alert('hello');";
  var obj = eval("("+str+")");
  ```

## 04_线程机制与事件机制
### 线程与进程
- 进程:
  - 程序的一次执行, 它占有一片独有的内存空间
  - 可以通过windows任务管理器查看进程
- 线程:
  - 是进程内的一个独立执行单元
  - 是程序执行的一个完整流程
  - 是CPU的最小的调度单元
- 关系
  - 一个进程至少有一个线程(主)
  - 程序是在某个进程中的某个线程执行的

### 浏览器内核模块组成
- 主线程
  - js引擎模块 : 负责js程序的编译与运行
  - html,css文档解析模块 : 负责页面文本的解析
  - DOM/CSS模块 : 负责dom/css在内存中的相关处理 
  - 布局和渲染模块 : 负责页面的布局和效果的绘制(内存中的对象)
- 分线程
  - 定时器模块 : 负责定时器的管理
  - DOM事件模块 : 负责事件的管理
  - 网络请求模块 : 负责Ajax请求

### js线程
- js是单线程执行的(回调函数也是在主线程)
- H5提出了实现多线程的方案: Web Workers
- 只能是主线程更新界面

### 定时器问题:
- 定时器并不真正完全定时
- 如果在主线程执行了一个长时间的操作, 可能导致延时才处理
    
### 事件处理机制(图)
- 代码分类
  - 初始化执行代码: 包含绑定dom事件监听, 设置定时器, 发送ajax请求的代码
  - 回调执行代码: 处理回调逻辑
- js引擎执行代码的基本流程: 
  - 初始化代码===>回调代码
- 模型的2个重要组成部分:
  - 事件管理模块
  - 回调队列
- 模型的运转流程
  - 执行初始化代码, 将事件回调函数交给对应模块管理
  - 当事件发生时, 管理模块会将回调函数及其数据添加到回调列队中
  - 只有当初始化代码执行完后(可能要一定时间), 才会遍历读取回调队列中的回调函数执行
    
### H5 Web Workers
- 可以让js在分线程执行
- Worker
  ```
  var worker = new Worker('worker.js');
  worker.onMessage = function(event){event.data} : 用来接收另一个线程发送过来的数据的回调
  worker.postMessage(data1) : 向另一个线程发送数据
  ```
- 问题:
  - worker内代码不能操作DOM更新UI
  - 不是每个浏览器都支持这个新特性
  - 不能跨域加载JS

- svn版本控制
- svn server