# 打包自定义工具库

## 1.创建工具包项目

### 1.1.安装 Node

- 检查是否已经安装 node(node 中自带 npm)

![image-20201210213800033](https://zxfjd3g.github.io/atguigu_utils-docs/assets/img/image-20201210213800033.ab975808.png)

- 如果 node 与 npm 命令不识别,说明你还没有安装 node
- 安装 node, 这里我就不带大家一步一步安装了(比较简单)
  - 方案一: 下载尚硅谷 node 的视频教程来学习安装
  - 方案二: 百度查找 node 的安装教程

### 1.2.创建项目

```bash
# 创建一个空的项目文件夹: atguigu-utils
# 在文件夹下执行命令
npm init -y
```

### 1.3.下载依赖包

```shell
npm i webpack webpack-cli
```

### 1.4.配置 webpack

- `webpack.config.js`

```js
const path = require("path");
module.exports = {
  // 模式
  mode: "development", // 也可以使用 production
  // 入口
  entry: "./src/index.js",
  // 出口
  output: {
    // 打包文件夹
    path: path.resolve(__dirname, "dist"),
    // 打包文件
    filename: "atguigu-utils.js",
    // 向外暴露的对象的名称
    library: "aUtils",
    // 打包生成库可以通过esm/commonjs/reqirejs的语法引入
    libraryTarget: "umd",
  },
};
```

### 1.5.在入口 JS 中暴露功能

- `src/index.js`

```js
export function test() {
  document.write("测试自定义包");
  console.log("test()");
}
```

### 1.6.配置打包命令

- `package.json`

```json
"scripts": {
  "build:watch": "webpack --watch"
},
```

### 1.7.对项目进行打包

```bash
npm run build:watch
```

### 1.8.测试使用自定义包

- `test/first.html`

```html
<body>
  <script src="../dist/atguigu-utils.js"></script>
  <script>
    aUtils.test();
  </script>
</body>
```

![image-20201204142438695](data:image/png;base64,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)

## 2.发布到 npm 中央仓库

### 2.1.完善 package.json

- 注意:
  - name: 必须是唯一的名称(在 npm 在线中央仓库中没有同名的)
  - main: 必须指定为打包生成的 js 文件
  - keywords: 指定一些方便别的程序员搜索到当前库的关键字

```json
{
  "name": "utils",
  "version": "1.0.0",
  "author": "xfzhang",
  "description": "尚硅谷-前端-自定义工具函数库",
  "keywords": [
    "atguigu",
    "utils",
    "array",
    "object",
    "function",
    "string",
    "axios",
    "event-bus",
    "pub-sub",
    "promise"
  ],
  "main": "dist/atguigu-utils.js",
  "license": "MIT",
  "scripts": {
    "build:watch": "webpack --watch",
    "build": "webpack"
  },
  "devDependencies": {
    "webpack": "^5.10.0",
    "webpack-cli": "^4.2.0"
  }
}
```

### 2.2.npm 配置

- npm 配置的中央仓库不能是淘宝镜像
- 发布前必须执行: npm config set registry https://registry.npmjs.org/
- 不用发布时: npm config set registry http://registry.npm.taobao.org/
- 查看配置: npm config list

### 2.3.注册 npm 中央仓库账号

- 注册地址: https://www.npmjs.com/
- 关键信息: 用户名/密码/邮箱(需要验证)

![image-20201204150917555](https://zxfjd3g.github.io/atguigu_utils-docs/assets/img/image-20201204150917555.f1e4a9c5.png)

### 2.4.添加用户

- 执行: npm addUser
- 登陆 npm 仓库
- 依次指定用户名/密码/邮箱

![image-20201204151301849](https://zxfjd3g.github.io/atguigu_utils-docs/assets/img/image-20201204151301849.ccbd7c05.png)

### 2.5.发布仓库

- 执行: npm publish

![image-20201210143938993](https://zxfjd3g.github.io/atguigu_utils-docs/assets/img/image-20201210143938993.227d51a0.png)

- 发布失败, 原因是库的名称重复了, 修改 name 为一个唯一值, 再发布

![image-20201204153505733](https://zxfjd3g.github.io/atguigu_utils-docs/assets/img/image-20201204153505733.ef73a7ee.png)

### 2.6.更新代码后再发布

- 修改项目库的版本号: package.json 中的 version 从 1.0.0 改为 1.0.1, 注意一定要变大
- 修改代码后重新打包: npm run build
- 执行发布: npm publish

### 2.7.强制删除已发布的库

- 执行: npm unpublish --force
- 注意: 必须在 72 小时内, 否则不能再删除

## 3.使用自定义工具包

### 3.1.下载工具包

```shell
# 名称是你前面指定的库的名称
npm install a-utils2
```

### 3.2.网页中引入并使用

```html
<script src="./node_modules/a-utils2/dist/atguigu-utils.js"></script>
<script>
  aUtils.test();
</script>
```

### 3.3.模块化引入并使用

```js
// 使用ESM引入
import { test } from "a-utils2";
test();

// 使用commonjs引入
const { test } = require("a-utils2");
test();
```

# 各种自定义

## 1. 函数相关

### 1.1. call()& apply()& bind()

#### 1.1.1. API 说明

- call()
  - 语法: call(fn, obj, ...args)
  - 功能: 执行 fn, 使 this 为 obj, 并将后面的 n 个参数传给 fn(功能等同于函数对象的 call 方法)
- apply()
  - 语法: apply(fn, obj, args)
  - 功能: 执行 fn, 使 this 为 obj, 并将 args 数组中的元素传给 fn(功能等同于函数对象的 apply 方法)
- bind()
  - 语法: bind(fn, obj, ...args)
  - 功能: 给 fn 绑定 this 为 obj, 并指定参数为后面的 n 个参数 (功能等同于函数对象的 bind 方法)

#### 1.1.2.实现说明

- 区别 call()/apply()/bind()
  - call(obj)/apply(obj): 调用函数, 指定函数中的 this 为第一个参数的值
  - bind(obj): 返回一个新的函数, 新函数内部会调用原来的函数, 且 this 为 bind()指定的第一参数的值
  - 注意: 如果 obj 是 null/undefined, this 为 window
- 应用
  - call()/apply()应用: 根据伪数组生成真数组
  - bind(): react 中组件的自定义方法 / vue 中的事件回调函数内部
- 自定义 call()/apply()
  - 给 obj 添加一个临时方法, 方法名任意, 值为当前函数
  - 通过 obj 调用这个临时方法, 并将接收的参数传入
  - 删除 obj 上的这个临时方法属性
- 自定义实现 bind()
  - 返回一个新函数
  - 在新函数内部通过原函数对象的 call 方法来执行原函数
  - 指定原函数的 this 为 obj
  - 指定参数为 bind 调用的参数和后面新函数调用的参数

#### 1.1.3.编码实现

- 自定义函数对象的 call 方法: `src/function/call.js`

```js
/* 
自定义函数对象的call方法
*/
export function call(fn, obj, ...args) {
  console.log("call()");

  // 如果obj是undefined/null, this指定为window
  if (obj === undefined || obj === null) {
    // return fn(...args)
    obj = window;
  }

  // 给obj添加一个临时方法, 方法指向的函数就是fn
  obj.tempFn = fn;
  // 通过obj来调用这个方法 ==> 也就会执行fn函数 ==> 此时fn中的this肯定为obj
  const result = obj.tempFn(...args);
  // 删除obj上的临时方法
  delete obj.tempFn;
  // 返回fn执行的结果
  return result;
}
```

- 自定义函数对象的 apply 方法: `src/function/apply.js`

```js
/* 
自定义函数对象的apply方法
*/
export function apply(fn, obj, args) {
  console.log("apply()");

  // 如果obj是undefined/null, this指定为window
  if (obj === undefined || obj === null) {
    // return fn(...args)
    obj = window;
  }

  // 给obj添加一个临时方法, 方法指向的函数就是fn
  obj.tempFn = fn;
  // 通过obj来调用这个方法 ==> 也就会执行fn函数 ==> 此时fn中的this肯定为obj
  const result = obj.tempFn(...args);
  // 删除obj上的临时方法
  delete obj.tempFn;
  // 返回fn执行的结果
  return result;
}
```

- 自定义函数对象的 bind 方法: `src/function/bind.js`

```js
import { call } from "./call";
/* 
  自定义函数对象的bind方法
*/
export function bind(fn, obj, ...args) {
  console.log("bind()");
  // 返回一个新函数
  return (...args2) => {
    // 通过call调用原函数, 并指定this为obj, 实参为args与args2
    return call(fn, obj, ...args, ...args2);
  };
}
```

#### 1.1.4.测试

```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>函数的call/apply/bind()</title>
  </head>
  <body>
    <script src="../dist/atguigu-utils.js"></script>
    <script>
      var m = 11;
      function f(a, b) {
        console.log(a, b, this.m, this);
        return a + b;
      }

      const obj = { m: 22 };

      /* 测试内置的函数对象的call方法 */
      // console.log(f.call(obj, 1, 2, 3))
      // console.log(f.call(undefined, 1, 2, 3))

      /* 测试内置的函数对象的apply方法 */
      // console.log(f.apply(obj, [4, 5, 6]))
      // console.log(f.apply(undefined, [4, 5, 6]))

      /* 测试内置的函数对象的bind方法 */
      // const f2 = f.bind(obj)
      // // console.log(f(1, 2)) // bind()并没有改变函数本身, 接收调用原函数是不会有任何变化的
      // f2(3, 4) // 必须调用bind返回的新函数, 原函数中的this才是指定的obj
      // console.log(f.bind(obj, 1)(3, 4))  // 1 3 22 obj   4
      // console.log(f.bind(obj, 1, 2)(3, 4)) // 1 2, 22 obj  3    注意: 可以暂停视频, 先自己分析一下

      /* ******************************************************** */

      /* 测试自定义call() */
      // console.log(aUtils.call(f, obj, 1, 2, 3))
      // console.log(aUtils.call(f, undefined, 1, 2, 3))

      /* 测试自定义apply() */
      // console.log(aUtils.apply(f, obj, [1, 2, 3]))
      // console.log(aUtils.apply(f, undefined, [1, 2, 3]))

      /* 测试自定义bind() */
      console.log(aUtils.bind(f, obj)(1, 2));
      console.log(aUtils.bind(f, obj, 3)(1, 2));
      console.log(aUtils.bind(f, obj, 4)(1, 2));
      console.log(aUtils.bind(f, undefined, 4)(1, 2));
    </script>
  </body>
</html>
```

### 1.2. 函数节流与函数防抖

#### 1.2.1. 相关理解

- 事件频繁触发可能造成的问题?
  - 一些浏览器事件:window.onresize、window.mousemove 等，触发的频率非常高，会造成界面卡顿
  - 如果向后台发送请求，频繁触发，对服务器造成不必要的压力
- 如何限制事件处理函数频繁调用
  - 函数节流
  - 函数防抖
- 函数节流(throttle)
  - 理解:
    - 在函数需要频繁触发时: 函数执行一次后，只有大于设定的执行周期后才会执行第二次
    - 适合多次事件按时间做平均分配触发
  - 场景：
    - 窗口调整（resize）
    - 页面滚动（scroll）
    - DOM 元素的拖拽功能实现（mousemove）
    - 抢购疯狂点击（click）
- 函数防抖(debounce)
  - 理解:
    - 在函数需要频繁触发时: 在规定时间内，只让最后一次生效，前面的不生效。
    - 适合多次事件一次响应的情况
  - 场景:
    - 输入框实时搜索联想（keyup/input）
- 区别函数节流与防抖

![02_函数防抖与节流](data:image/jpeg;base64,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)

#### 1.2.2.API 说明

- throttle() 节流
  - 语法: throttle(callback, wait)
  - 功能: 创建一个节流函数，在 wait 毫秒内最多执行 `callback` 一次
- debounce() 防抖
  - 语法: debounce(callback, wait)
  - 功能: 创建一个防抖动函数，该函数会从上一次被调用后，延迟 `wait` 毫秒后调用 `callback`

#### 1.2.3.编码实现

- `src/function/throttle.js`: 函数节流

```js
/* 
实现函数节流
- 语法: throttle(callback, wait)
- 功能: 创建一个节流函数，在 wait 毫秒内最多执行 `callback` 一次
*/
export function throttle(callback, wait) {
  let start = 0;
  // 返回一个事件监听函数(也就是节流函数)
  return function (event) {
    console.log("throttle event");
    // 只有当距离上次处理的时间间隔超过了wait时, 才执行处理事件的函数
    const current = Date.now();
    if (current - start > wait) {
      callback.call(this, event); // 需要指定this和参数
      start = current;
    }
  };
}
```

- `src/function/debounce.js`: 函数防抖

```js
/* 
实现函数防抖
- 语法: debounce(callback, wait)
- 功能: 创建一个防抖动函数，该函数会从上一次被调用后，延迟 `wait` 毫秒后调用 `callback`
*/
export function debounce(callback, wait) {
  // 用来保存定时器任务的标识id
  let timeoutId = -1;
  // 返回一个事件监听函数(也就是防抖函数)
  return function (event) {
    console.log("debounce event");
    // 清除未执行的定时器任务
    if (timeoutId !== -1) {
      clearTimeout(timeoutId);
    }
    // 启动延迟 await 时间后执行的定时器任务
    timeoutId = setTimeout(() => {
      // 调用 callback 处理事件
      callback.call(this, event);
      // 处理完后重置标识
      timeoutId = -1;
    }, wait);
  };
}
```

#### 1.2.4.测试

```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>函数节流与防抖</title>
  </head>
  <body>
    <button id="handle">正常处理</button>
    <button id="throttle">测试函数节流</button>
    <button id="debounce">测试函数防抖</button>

    <script src="../dist/atguigu-utils.js"></script>
    <!-- <script src="../node_modules/atguigu-utils/dist/atguigu-utils.js"></script> -->
    <script>
      /* 处理点击事件的回调函数 */
      function handleClick(event) {
        // 处理事件的回调
        console.log("处理点击事件", this, event);
      }

      document.getElementById("handle").onclick = handleClick;
      document.getElementById("throttle").onclick = aUtils.throttle(
        handleClick,
        2000
      );
      document.getElementById("debounce").onclick = aUtils.debounce(
        handleClick,
        2000
      );
    </script>
  </body>
</html>
```

## 2. 数组相关

### 2.1. API 列表

1. map()
2. reduce()
3. filter()
4. find()
5. findIndex()
6. every()
7. some()
8. unique1() / unique2() / unique3()
9. concat()
10. slice()
11. flatten()
12. chunk() / chunk2()
13. difference()
14. pull()
15. pullAll()
16. drop()
17. dropRight()

### 2.2. 数组声明式系列方法

#### 2.2.1.使用数组声明式系列方法

- **map**(): 返回一个由回调函数的返回值组成的新数组
- **reduce**(): 从左到右为每个数组元素执行一次回调函数，并把上次回调函数的返回值放在一个暂存器中传给下次回调函数，并返回最后一次回调函数的返回值
- **filter**(): 将所有在过滤函数中返回 `true` 的数组元素放进一个新数组中并返回
- **find**(): 找到第一个满足测试函数的元素并返回那个元素的值，如果找不到，则返回 `undefined`。
- **findIndex**(): 找到第一个满足测试函数的元素并返回那个元素的索引，如果找不到，则返回 `-1`。
- **every**(): 如果数组中的每个元素都满足测试函数，则返回 `true`，否则返回 `false。`
- **some**(): 如果数组中至少有一个元素满足测试函数，则返回 true，否则返回 false。

#### 2.2.2.编码实现

- `src/array/declares.js`: 实现数组声明式处理系列工具函数

```js
/* 
实现map()
*/
export function map(array, callback) {
  const arr = [];
  for (let index = 0; index < array.length; index++) {
    // 将callback的执行结果添加到结果数组中
    arr.push(callback(array[index], index));
  }
  return arr;
}

/*
实现reduce() 
*/
export function reduce(array, callback, initValue) {
  let result = initValue;
  for (let index = 0; index < array.length; index++) {
    // 调用回调函数将返回的结果赋值给result
    result = callback(result, array[index], index);
  }
  return result;
}

/* 
实现filter()
*/
export function filter(array, callback) {
  const arr = [];
  for (let index = 0; index < array.length; index++) {
    if (callback(array[index], index)) {
      arr.push(array[index]);
    }
  }
  return arr;
}

/* 
实现find()
*/
export function find(array, callback) {
  for (let index = 0; index < array.length; index++) {
    if (callback(array[index], index)) {
      return array[index];
    }
  }
  return undefined;
}

/* 
实现findIndex()
*/
export function findIndex(array, callback) {
  for (let index = 0; index < array.length; index++) {
    if (callback(array[index], index)) {
      return index;
    }
  }
  return -1;
}

/* 
 实现every()
 */
export function every(array, callback) {
  for (let index = 0; index < array.length; index++) {
    if (!callback(array[index], index)) {
      // 只有一个结果为false, 直接返回false
      return false;
    }
  }
  return true;
}

/* 
实现some()
*/
export function some(array, callback) {
  for (let index = 0; index < array.length; index++) {
    if (callback(array[index], index)) {
      // 只有一个结果为true, 直接返回true
      return true;
    }
  }
  return false;
}
```

#### 2.2.3.测试

```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>数组声明式系列方法</title>
  </head>
  <body>
    <script src="../dist/atguigu-utils.js"></script>
    <script>
      /* 
    需求:
    1. 产生一个每个元素都比原来大10的新数组
    2. 得到所有奇数的和
    3. 得到值大于8且下标是偶数位的元素组成的数组
    4. 找出一个值大于8且下标是偶数位的元素
    5. 找出一个值大于8且下标是偶数位的元素的下标
    6. 判断下标为偶数的元素是否都为奇数
    7. 判断是否有下标为偶数的元素值为奇数
    */

      const arr = [1, 3, 6, 9, 15, 19, 16];

      /* 使用数组内置方法 */
      // console.log(arr.map((item, index) => item + 10))
      // console.log(arr.reduce((preTotal, item, index) => {
      //   return preTotal + (item%2===1 ? item : 0)
      // }, 0))
      // console.log(arr.filter((item, index) => item>8 && index%2===0))
      // console.log(arr.find((item, index) => item>8 && index%2===0))
      // console.log(arr.findIndex((item, index) => item>8 && index%2===0))
      // console.log(arr.every((item, index) => index%2===1 || item%2===1))
      // console.log(arr.some((item, index) => index%2===0 && item%2===1))

      /* 使用自定义工具函数 */
      console.log(aUtils.map(arr, (item, index) => item + 10));
      console.log(
        aUtils.reduce(
          arr,
          (preTotal, item, index) => {
            return preTotal + (item % 2 === 1 ? item : 0);
          },
          0
        )
      );
      console.log(
        aUtils.filter(arr, (item, index) => item > 8 && index % 2 === 0)
      );
      console.log(
        aUtils.find(arr, (item, index) => item > 8 && index % 2 === 0)
      );
      console.log(
        aUtils.findIndex(arr, (item, index) => item > 8 && index % 2 === 0)
      );
      console.log(
        aUtils.every(arr, (item, index) => index % 2 === 1 || item % 2 === 1)
      );
      console.log(
        aUtils.some(arr, (item, index) => index % 2 === 0 && item % 2 === 1)
      );
    </script>
  </body>
</html>
```

### 2.3.数组去重

#### 2.3.1.API 说明

- 根据当前数组产生一个去除重复元素后的新数组
- 如: [2, 3, 2, 7, 6, 7] ==> [2, 3, 7, 6]

#### 2.3.2. 实现

- 方法 1: 利用 forEach()和 indexOf()
  - 说明: 本质是双重遍历, 效率差些
- 方法 2: 利用 forEach() + 对象容器
  - 说明: 只需一重遍历, 效率高些
- 方法 3: 利用 ES6 语法: from + Set 或者 ... + Set
  - 说明: 编码简洁

#### 2.3.3. 编码实现

- `src/array/unique.js`

```js
/*
方法1: 利用forEach()和indexOf()
  说明: 本质是双重遍历, 效率差些
*/
export function unique1(array) {
  const arr = [];
  array.forEach((item) => {
    if (arr.indexOf(item) === -1) {
      arr.push(item);
    }
  });
  return arr;
}

/*
方法2: 利用forEach() + 对象容器
  说明: 只需一重遍历, 效率高些
*/
export function unique2(array) {
  const arr = [];
  const obj = {};
  array.forEach((item) => {
    if (!obj.hasOwnProperty(item)) {
      obj[item] = true;
      arr.push(item);
    }
  });
  return arr;
}

/*
方法3: 利用ES6语法
    1). from + Set
    2). ... + Set
    说明: 编码简洁
*/
export function unique3(array) {
  // return Array.from(new Set(array))
  return [...new Set(array)];
}
```

#### 2.3.4.测试

```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>数组去重</title>
  </head>
  <body>
    <script src="../dist/atguigu-utils.js"></script>
    <script>
      console.log(aUtils.unique1([2, 3, 2, 7, 6, 7]));
      console.log(aUtils.unique2([2, 3, 2, 7, 6, 7]));
      console.log(aUtils.unique3([2, 3, 2, 7, 6, 7]));
    </script>
  </body>
</html>
```

### 2.4.数组合并与切片

#### 2.4.1. API 说明

- concat(): 合并
  - 语法: var new_array = concat(array, value1[, value2[, ...[, valueN]]])
  - 功能: 将 n 个数组或值与当前数组合并生成一个新数组, 原始数组不会被改变
- slice(): 切片
  - 语法: var new_array = slice(array, [begin[, end]])
  - 功能: 返回一个由 begin 和 end 决定的原数组的浅拷贝, 原始数组不会被改变

#### 2.4.2.编码实现

- `src/array/concat.js`: 自定义数组合并

```js
/* 
语法: var new_array = concat(old_array, value1[, value2[, ...[, valueN]]]) 
功能: 将n个数组或值与当前数组合并生成一个新数组
*/
export function concat(array, ...values) {
  const arr = [...array];
  values.forEach((value) => {
    if (Array.isArray(value)) {
      arr.push(...value);
    } else {
      arr.push(value);
    }
  });
  return arr;
}
```

- `src/array/slice.js`: 自定义数组切片

```js
/* 
  语法: var new_array = slice(oldArr, [begin[, end]])
  功能: 返回一个由 begin 和 end 决定的原数组的浅拷贝, 原始数组不会被改变
*/
export function slice(array, begin, end) {
  // 如果当前数组是[], 直接返回[]
  if (array.length === 0) {
    return [];
  }

  // 如果begin超过最大下标, 直接返回[]
  begin = begin || 0;
  if (begin >= array.length) {
    return [];
  }

  // 如果end不大于begin, 直接返回[]
  end = end || array.length;
  if (end > array.length) {
    end = array.length;
  }
  if (end <= begin) {
    return [];
  }

  // 取出下标在[begin, end)区间的元素, 并保存到最终的数组中
  const arr = [];
  for (let index = begin; index < end; index++) {
    arr.push(array[index]);
  }

  return arr;
}
```

#### 2.4.3.测试

```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>数组合并与切片</title>
  </head>
  <body>
    <script src="../dist/atguigu-utils.js"></script>
    <script>
      console.log(aUtils.concat([1, 2], [3, 4], 6)); // [1, 2, 3, 4, 6]

      console.log(aUtils.slice([1, 3, 5, 7, 9])); // [1, 3, 5, 7, 9]
      console.log(aUtils.slice([1, 3, 5, 7, 9], 1, 3)); // [3, 5]
      console.log(aUtils.slice([1, 3, 5, 7, 9], 1, 10)); // [3, 5, 7, 9]
    </script>
  </body>
</html>
```

### 2.5.数组扁平化

#### 2.5.1.API 说明

- 语法: flatten(array)
- 取出嵌套数组(多维)中的所有元素放到一个新数组(一维)中
- 如: [1, [3, [2, 4]]] ==> [1, 3, 2, 4]

#### 2.5.2.编码实现

- `src/array/flatten.js`
- 方法一: 递归 + reduce() + concat()
- 方法二: ... + some() + concat()

```js
/* 
数组扁平化: 取出嵌套数组(多维)中的所有元素放到一个新数组(一维)中
  如: [1, [3, [2, 4]]]  ==>  [1, 3, 2, 4]
*/

/*
方法一: 递归 + reduce() + concat()
*/
export function flatten1(array) {
  return array.reduce((pre, item) => {
    if (Array.isArray(item) && item.some((cItem) => Array.isArray(cItem))) {
      return pre.concat(flatten1(item));
    } else {
      return pre.concat(item);
    }
  }, []);
}

/*
方法二: ... + some() + concat()
*/
export function flatten2(array) {
  let arr = [].concat(...array);
  while (arr.some((item) => Array.isArray(item))) {
    arr = [].concat(...arr);
  }
  return arr;
}
```

#### 2.5.3.测试

```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>数组扁平化</title>
  </head>
  <body>
    <script src="../dist/atguigu-utils.js"></script>
    <script>
      console.log(aUtils.flatten1([1, [3, [2, 4]]]));
      console.log(aUtils.flatten2([1, [3, [2, 4]]]));
    </script>
  </body>
</html>
```

### 2.6.数组分块

#### 2.6.1.API 说明

- 语法: chunk(array, size)
- 功能: 将数组拆分成多个 size 长度的区块，每个区块组成小数组,整体组成一个二维数组
- 如: [1, 3, 5, 6, 7, 8] 调用 chunk(arr, 4) ==> [[1, 3, 5, 6], [7,8]]

#### 2.6.2.编码实现

- `src/array/chunk.js`

```js
/* 
将数组拆分成多个 size 长度的区块，每个区块组成小数组,整体组成一个二维数组
*/
export function chunk(array, size) {
  if (array.length === 0) {
    return [];
  }
  size = size || 1;

  const bigArr = [];
  let smallArr = [];

  array.forEach((item) => {
    if (smallArr.length === 0) {
      bigArr.push(smallArr);
    }
    smallArr.push(item);
    if (smallArr.length === size) {
      smallArr = [];
    }
  });

  return bigArr;
}
```

#### 2.6.3.测试

```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>数组分块</title>
  </head>
  <body>
    <script src="../dist/atguigu-utils.js"></script>
    <script>
      console.log(aUtils.chunk([1, 2, 3, 4, 5, 6, 7], 3)); // [[1,2,3], [4,5,6],[7]]
      console.log(aUtils.chunk([1, 2, 3, 4, 5, 6, 7])); // [[1],[2],[3],[4],[5],[6],[7]]
      console.log(aUtils.chunk([1, 2, 3, 4, 5, 6, 7], 8)); // [[1, 2, 3, 4, 5, 6, 7]]
    </script>
  </body>
</html>
```

### 2.7.数组取差异

#### 2.7.1.API 说明

- 语法: difference(arr1, arr2)
- 功能: 得到当前数组中所有不在 arr 中的元素组成的数组(不改变原数组)
- 例子: difference([1,3,5,7], [5, 8]) ==> [1, 3, 7]

#### 2.7.2.编码实现

- `src/array/difference.js`

```js
/* 
difference(arr1, arr2): 得到arr1中所有不在arr2中的元素组成的数组(不改变原数组)
    如: [1,3,5,7].difference([5, 8])  ==> [1, 3, 7]
*/
export function difference(arr1, arr2) {
  if (arr1.length === 0) {
    return [];
  } else if (arr2.length === 0) {
    return arr1.slice();
  }
  return arr1.filter((item) => arr2.indexOf(item) === -1);
}
```

#### 2.7.3.测试

```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>数组取差异</title>
  </head>
  <body>
    <script src="../dist/atguigu-utils.js"></script>
    <script>
      console.log(aUtils.difference([1, 3, 5, 7], [5, 8]));
    </script>
  </body>
</html>
```

### 2.8.删除数组中部分元素

#### 2.8.1.API 相关

- pull(array, ...values):
  - 删除原数组中与 value 相同的元素, 返回所有删除元素的数组
  - 说明: 原数组发生了改变
  - 如: pull([1,3,5,3,7], 2, 7, 3, 7) ===> 原数组变为[1, 5], 返回值为[3,3,7]
- pullAll(array, values):
  - 功能与 pull 一致, 只是参数变为数组
  - 如: pullAll([1,3,5,3,7], [2, 7, 3, 7]) ===> 数组 1 变为[1, 5], 返回值为[3,3,7]

#### 2.8.2. 编码实现

- src/array/pull.js

```js
/* 
1. pull(array, ...values): 
  删除数组中与value相同的元素, 返回所有删除元素的数组
  说明: 数组发生了改变
  如: pull([1,3,5,3,7], 2, 7, 3, 7) ===> 数组变为[1, 5], 返回值为[3,3,7]
2. pullAll(array, values): 
  功能与pull一致, 只是参数变为数组
  如: pullAll([1,3,5,3,7], [2, 7, 3, 7]) ===> 数组变为[1, 5], 返回值为[3,3,7]
*/
export function pull(array, ...values) {
  if (array.length === 0 || values.length === 0) {
    return [];
  }

  var result = [];
  for (let index = 0; index < array.length; index++) {
    const item = array[index];
    if (values.indexOf(item) !== -1) {
      array.splice(index, 1);
      result.push(item);
      index--;
    }
  }

  return result;
}

export function pullAll(array, values) {
  if (!values || !Array.isArray(values)) {
    return [];
  }
  return pull(array, ...values);
}
```

#### 2.8.3.测试

```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>删除数组中部分元素</title>
  </head>
  <body>
    <script src="../dist/atguigu-utils.js"></script>
    <script>
      var arr = [1, 3, 5, 3, 7];
      console.log(aUtils.pull(arr, 2, 7, 3, 7), arr);
      var arr2 = [1, 3, 5, 3, 7];
      console.log(aUtils.pullAll(arr2, [2, 7, 3, 7]), arr2);
    </script>
  </body>
</html>
```

2.9. 得到数组的部分元素

#### 2.9.1.API 相关

- drop(array, count)
  - 得到当前数组过滤掉左边 count 个后剩余元素组成的数组
  - 说明: 不改变当前数组, count 默认是 1
  - 如: drop([1,3,5,7], 2) ===> [5, 7]
- dropRight(array, count)
  - 得到当前数组过滤掉右边 count 个后剩余元素组成的数组
  - 说明: 不改变当前数组, count 默认是 1
  - 如: dropRight([1,3,5,7], 2) ===> [1, 3]

#### 2.9.2. 编码实现

- src/array/drop.js

```js
/* 
1. drop(array, count): 
   得到数组过滤掉左边count个后剩余元素组成的数组
   说明: 不改变当前数组, count默认是1
   如: drop([1,3,5,7], 2) ===> [5, 7]
2. dropRight(array, count): 
   得到数组过滤掉右边count个后剩余元素组成的数组
   说明: 不改变数组, count默认是1
   如: dropRight([1,3,5,7], 2) ===> [1, 3]
*/

export function drop(array, count = 1) {
  if (array.length === 0 || count >= array.length) {
    return [];
  }

  return array.filter((item, index) => index >= count);
}

export function dropRight(array, count = 1) {
  if (array.length === 0 || count >= array.length) {
    return [];
  }

  return array.filter((item, index) => index < array.length - count);
}
```

#### 2.9.3.测试

```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>得到数组的部分元素</title>
  </head>
  <body>
    <script src="../dist/atguigu-utils.js"></script>
    <script>
      console.log(aUtils.drop([1, 3, 5, 7], 2));
      console.log(aUtils.drop([1, 3, 5, 7], 4));
      console.log(aUtils.drop([1, 3, 5, 7]));

      console.log(aUtils.dropRight([1, 3, 5, 7], 2));
      console.log(aUtils.dropRight([1, 3, 5, 7], 4));
      console.log(aUtils.dropRight([1, 3, 5, 7]));
    </script>
  </body>
</html>
```

## 3. 对象相关

### 3.1.相关 API

- newInstance()
- myInstanceOf()
- mergeObject()
- clone1() / clone2()
- deepClone1() / deepClone2() / deepClone3() / deepClone4()

### 3.2.自定义 new

#### 3.2.1.API 相关

- 语法: newInstance(Fn, ...args)
- 功能: 创建 Fn 构造函数的实例对象

#### 3.2.3.编码实现

- `src/object/newInstance.js`

```js
export function newInstance(Fn, ...args) {
  // 创建一个空的object实例对象obj, 作为Fn的实例对象
  const obj = {};
  // 将Fn的prototype属性值赋值给obj的__proto__属性值
  obj.__proto__ = Fn.prototype;
  // 调用Fn, 指定this为obj, 参数为args列表
  const result = Fn.call(obj, ...args);
  // 如果Fn返回的是一个对象类型, 那返回的就不再是obj, 而是Fn返回的对象
  // 否则返回obj
  return result instanceof Object ? result : obj;
}
```

#### 3.2.3.测试

```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>自定义new</title>
  </head>
  <body>
    <script src="../dist/atguigu-utils.js"></script>
    <script>
      function Person(name, age) {
        this.name = name;
        this.age = age;
        // return {}
        // return []
        // return function (){}
        // return 1
        // return undefined
      }

      const p = new Person("tom", 12);
      console.log(p);

      const p2 = aUtils.newInstance(Person, "Jack", 13);
      console.log(p2, p2.constructor);
    </script>
  </body>
</html>
```

### 3.3.自定义 instanceof

#### 3.3.1. API 相关

- 语法: myInstanceOf(obj, Type)
- 功能: 判断 obj 是否是 Type 类型的实例
- 实现: Type 的原型对象是否是 obj 的原型链上的某个对象, 如果是返回 tru, 否则返回 false

#### 3.3.2.编码实现

- `src/object/myInstanceOf.js`

```js
export function myInstanceOf(obj, Type) {
  // 得到原型对象
  let protoObj = obj.__proto__;

  // 只要原型对象存在
  while (protoObj) {
    // 如果原型对象是Type的原型对象, 返回true
    if (protoObj === Type.prototype) {
      return true;
    }
    // 指定原型对象的原型对象
    protoObj = protoObj.__proto__;
  }

  return false;
}
```

#### 3.3.3. 测试

```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>自定义instanceof</title>
  </head>
  <body>
    <script src="../dist/atguigu-utils.js"></script>
    <script>
      function Person(name, age) {
        this.name = name;
        this.age = age;
      }
      const p = new Person("tom", 12);

      console.log(aUtils.myInstanceOf(p, Object), p instanceof Object);
      console.log(aUtils.myInstanceOf(p, Person), p instanceof Person);
      console.log(aUtils.myInstanceOf(p, Function), p instanceof Function);
    </script>
  </body>
</html>
```

### 3.4.合并多个对象

#### 3.4.1.API 相关

- 语法: object mergeObject(...objs)
- 功能: 合并多个对象, 返回一个合并后对象(不改变原对象)
- 例子:
  - { a: [{ x: 2 }, { y: 4 }], b: 1}
  - { a: { z: 3}, b: [2, 3], c: 'foo'}
  - 合并后: { a: [ { x: 2 }, { y: 4 }, { z: 3 } ], b: [ 1, 2, 3 ], c: 'foo' }

#### 3.4.2.编码实现

- `src/object/mergeObject.js`

```js
export function mergeObject(...objs) {
  const result = {};

  // 遍历objs
  objs.forEach((obj) => {
    Object.keys(obj).forEach((key) => {
      // 如果result还没有key值属性
      if (!result.hasOwnProperty(key)) {
        result[key] = obj[key];
      } else {
        // 否则 合并属性
        result[key] = [].concat(result[key], obj[key]);
      }
    });
  });

  // 可以使用reduce来代替forEach手动添加
  return result;
}
```

#### 3.4.3.测试

```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>合并多个对象</title>
  </head>
  <body>
    <script src="../dist/atguigu-utils.js"></script>
    <script>
      const object = {
        a: [{ x: 2 }, { y: 4 }],
        b: 1,
      };
      const other = {
        a: { z: 3 },
        b: [2, 3],
        c: "foo",
      };
      console.log(aUtils.merge(object, other));
    </script>
  </body>
</html>
```

### 3.5. 对象/数组拷贝

#### 3.5.1.区别浅拷贝与深拷贝

- 纯语言表达:
  - 浅拷贝: 只是复制了对象属性或数组元素本身(只是引用地址值)
  - 深拷贝: 不仅复制了对象属性或数组元素本身, 还复制了指向的对象(使用递归)
- 举例说明: 拷贝 persons 数组(多个人对象的数组)
  - 浅拷贝: 只是拷贝了每个 person 对象的引用地址值, 每个 person 对象只有一份
  - 深拷贝: 每个 person 对象也被复制了一份新的

#### 3.5.2.实现浅拷贝

- `src/object/clone.js`

```js
/* 
实现浅拷贝
  方法一: 利用ES6语法
  方法二: 利用ES5语法: for...in
*/
/* 方法一: 利用ES6语法*/
export function clone1(target) {
  // 如果是对象(不是函数, 也就是可能是object对象或者数组)
  if (target != null && typeof target === "object") {
    if (target instanceof Array) {
      // return target.slice()
      // return target.filter(() => true)
      // return target.map(item => item)
      return [...target];
    } else {
      // return Object.assign({}, target)
      return { ...target };
    }
  }
  // 基本类型或者函数, 直接返回
  return target;
}

/* 方法二: 利用ES5语法: for...in */
export function clone2(target) {
  if (target != null && typeof target === "object") {
    const cloneTarget = Array.isArray(target) ? [] : {};
    for (let key in target) {
      if (target.hasOwnProperty(key)) {
        cloneTarget[key] = target[key];
      }
    }
    return cloneTarget;
  } else {
    return target;
  }
}
```

#### 3.5.3.实现深拷贝

- 实现一: 大众乞丐版
  - 问题 1: 函数属性会丢失
  - 问题 2: 循环引用会出错
- 实现二: 面试基础版
  - 解决问题 1: 函数属性还没丢失
- 实现三: 面试加强版本
  - 解决问题 2: 循环引用正常
- 实现四: 面试加强版本 2(优化遍历性能)
  - 数组: while | for | forEach() 优于 for-in | keys()&forEach()
  - 对象: for-in 与 keys()&forEach() 差不多
- 编码实现: `src/object/deepClone.js`

```js
/* 
深度克隆
1). 大众乞丐版
    问题1: 函数属性会丢失
    问题2: 循环引用会出错
2). 面试基础版本
    解决问题1: 函数属性还没丢失
3). 面试加强版本
    解决问题2: 循环引用正常
4). 面试加强版本2(优化遍历性能)
    数组: while | for | forEach() 优于 for-in | keys()&forEach() 
    对象: for-in 与 keys()&forEach() 差不多
*/

/* 
1). 大众乞丐版
    问题1: 函数属性会丢失
    问题2: 循环引用会出错
*/
export function deepClone1(target) {
  return JSON.parse(JSON.stringify(target));
}

/* 
2). 面试基础版本
    解决问题1: 函数属性还没丢失
*/
export function deepClone2(target) {
  if (target !== null && typeof target === "object") {
    const cloneTarget = target instanceof Array ? [] : {};

    for (const key in target) {
      if (target.hasOwnProperty(key)) {
        cloneTarget[key] = deepClone2(target[key]);
      }
    }

    return cloneTarget;
  }

  return target;
}

/* 
3). 面试加强版本
    解决问题2: 循环引用正常
*/
export function deepClone3(target, map = new Map()) {
  if (target !== null && typeof target === "object") {
    // 从缓存容器中读取克隆对象
    let cloneTarget = map.get(target);
    // 如果存在, 返回前面缓存的克隆对象
    if (cloneTarget) {
      return cloneTarget;
    }
    // 创建克隆对象(可能是{}或者[])
    cloneTarget = target instanceof Array ? [] : {};
    // 缓存到map中
    map.set(target, cloneTarget);

    for (const key in target) {
      if (target.hasOwnProperty(key)) {
        // 递归调用, 深度克隆对象, 且传入缓存容器map
        cloneTarget[key] = deepClone3(target[key], map);
      }
    }

    return cloneTarget;
  }

  return target;
}

/* 
4). 面试加强版本2(优化遍历性能)
    数组: while | for | forEach() 优于 for-in | keys()&forEach() 
    对象: for-in 与 keys()&forEach() 差不多
*/
export function deepClone4(target, map = new Map()) {
  if (target !== null && typeof target === "object") {
    // 从缓存容器中读取克隆对象
    let cloneTarget = map.get(target);
    // 如果存在, 返回前面缓存的克隆对象
    if (cloneTarget) {
      return cloneTarget;
    }
    // 创建克隆对象(可能是{}或者[])
    if (target instanceof Array) {
      cloneTarget = [];
      // 缓存到map中
      map.set(target, cloneTarget);
      target.forEach((item, index) => {
        cloneTarget[index] = deepClone4(item, map);
      });
    } else {
      cloneTarget = {};
      // 缓存到map中
      map.set(target, cloneTarget);
      Object.keys(target).forEach((key) => {
        cloneTarget[key] = deepClone4(target[key], map);
      });
    }

    return cloneTarget;
  }

  return target;
}
```

#### 3.5.4.测试

- 浅拷贝测试

```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>浅克隆/浅复制/浅拷贝</title>
  </head>
  <body>
    <!-- 
    实现浅拷贝
        方法一: 利用ES6语法
        方法二: 利用ES5语法: for...in
  -->
    <script src="../dist/atguigu-utils.js"></script>
    <script>
      const obj1 = { x: "abc", y: { m: 1 } };
      // const obj2 = aUtils.clone1(obj1)
      const obj2 = aUtils.clone2(obj1);
      console.log(obj2, obj2 === obj1, obj2.x === obj1.x, obj2.y === obj1.y);

      const arr1 = ["abc", { m: 1 }];
      // const arr2 = aUtils.clone1(arr1)
      const arr2 = aUtils.clone2(arr1);
      console.log(
        arr2,
        arr2 === arr1,
        arr2[0] === arr1[0],
        arr2[1] === arr1[1]
      );
    </script>
  </body>
</html>
```

- 深拷贝测试

```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>深度克隆/深复制/深拷贝</title>
  </head>
  <body>
    <script src="https://cdn.bootcss.com/lodash.js/4.17.15/lodash.min.js"></script>
    <script src="../dist/atguigu-utils.js"></script>
    <script>
      const obj1 = {
        a: 1,
        b: ["e", "f", "g"],
        c: { h: { i: 2 } },
        d: function () {},
      };
      obj1.b.push(obj1.c);
      obj1.c.j = obj1.b;

      // const obj2 = _.cloneDeep(obj1)
      // const obj2 = aUtils.deepClone1(obj1)
      // const obj2 = aUtils.deepClone2(obj1)
      // const obj2 = aUtils.deepClone3(obj1)
      const obj2 = aUtils.deepClone4(obj1);
      console.log(obj2, obj2.c === obj1.c, obj2.d === obj1.d);
    </script>
  </body>
</html>
```

## 4.字符串相关

### 4.1. API 相关

- 字符串倒序
  - 语法: reverseString(str)
  - 功能: 生成一个倒序的字符串
- 字符串是否是回文
  - 语法: palindrome(str)
  - 功能: 如果给定的字符串是回文，则返回 true ；否则返回 false
- 截取字符串
  - 语法: truncate(str, num)
  - 功能: 如果字符串的长度超过了 num, 截取前面 num 长度部分, 并以...结束

### 4.2. 编码实现

- `src/string/index.js`

```js
/* 
1. 字符串倒序: reverseString(str)  生成一个倒序的字符串
*/
export function reverseString(str) {
  // return str.split('').reverse().join('')
  // return [...str].reverse().join('')
  return Array.from(str).reverse().join("");
}

/* 
2. 字符串是否是回文: palindrome(str) 如果给定的字符串是回文，则返回 true ；否则返回 false
*/
export function palindrome(str) {
  return str === reverseString(str);
}

/* 
3. 截取字符串: truncate(str, num) 如果字符串的长度超过了num, 截取前面num长度部分, 并以...结束
*/
export function truncate(str, num) {
  return str.length > num ? str.slice(0, num) + "..." : str;
}
```

### 4.3.测试

```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>字符串处理的系列方法</title>
  </head>
  <body>
    <script src="../dist/atguigu-utils.js"></script>
    <script>
      console.log(aUtils.reverseString("abcd")); // dcba
      console.log(aUtils.palindrome("abcb"), aUtils.palindrome("abcba")); // false true
      console.log(aUtils.truncate("boomerang", 7)); // boomera...
    </script>
  </body>
</html>
```

## 6.手写 DOM 事件监听(带委托)

### 6.1. 理解事件冒泡与事件委托

- 事件冒泡的流程
  - 基于 DOM 树形结构
  - 事件在目标元素上处理后, 会由内向外(上)逐层传递
  - 应用场景: 事件代理/委托/委派

![image-20201215141059095](https://zxfjd3g.github.io/atguigu_utils-docs/assets/img/image-20201215141059095.a3dce0aa.png)

- 事件委托/代理
  - 将多个子元素的同类事件监听委托给(绑定在)共同的一个父组件上
  - 好处：
    - 减少内存占用(事件监听回调从 n 变为
    - 动态添加的内部元素也能响应

### 6.2. API 相关

- 语法：addEventListener(element, type, fn, selector)
- 说明：如果 selector 没有，直接给 element 绑定事件，如果 selector 有，将 selector 对应的多个元素的事件委托绑定给父元素 element

### 6.2.编码实现

- src/event-bind/index.js

```js
/* 
语法：addEventListener(element, type, fn, selector)
说明：如果selector没有，直接给element绑定事件，
  如果selector有，将selector对应的多个元素的事件委托绑定给父元素element
*/
export function addEventListener(element, type, fn, selector) {
  // 如果没有指定selector, 普通的事件绑定
  if (!selector) {
    element.addEventListener(type, fn);
  } else {
    // 否则是代委托的事件绑定
    element.addEventListener(type, function (event) {
      // 得到真正发生事件的目标元素
      const target = event.target;
      // 如果与选择器匹配
      if (target.matches(selector)) {
        // 调用处理事件的回调fn, 并指定this为目标元素, 参数为event
        fn.call(target, event);
      }
    });
  }
}
```

### 6.3.测试

```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>自定义事件监听</title>
  </head>
  <body>
    <ul>
      <li>AAA1</li>
      <li>AAA2</li>
      <li>AAA3</li>
      <li>AAA4</li>
    </ul>

    <!-- 功能: 点击每行提示对应的文本 -->
    <script src="../dist/atguigu-utils.js"></script>
    <script>
      // 不使用事件委托
      // document.querySelectorAll('ul>li').forEach(li => {
      //   // li.addEventListener('click', function (event) {
      //   //   alert(this.innerHTML)
      //   // })
      //   aUtils.addEventListener(li, 'click', function (event) {
      //     // alert(event.target.innerHTML)
      //     alert(this.innerHTML)
      //   })
      // })

      // 使用事件委托
      const ul = document.querySelector("ul");
      aUtils.addEventListener(
        ul,
        "click",
        function (event) {
          // alert(this.innerHTML)
          alert(event.target.innerHTML);
        },
        "li"
      );
    </script>
  </body>
</html>
```

## 7.手写 ajax 请求函数

### 7.1.API 相关

- 语法：
  - axios(options)
    - 参数配置对象：url, method, params 与 data
    - 返回值为：promise 对象
  - axios.get(url, options)
  - axios.post(url, data, options)
  - axios.put(url, data, options)
  - axios.delete(url, options)
- 功能：使用 xhr 发送 ajax 请求的工具函数，与 axios 库功能类似

### 7.2. 实现整体流程

1. 函数的参数为一个配置对象
   { url: '', // 请求地址 method: '', // 请求方式 GET/POST/PUT/DELETE params: {}, // GET/DELETE 请求的 query 参数 data: {}, // POST 或 DELETE 请求的请求体参数 }
2. 返回值: 函数的返回值为 promise, 成功的结果为 response, 失败的结果为 error
3. 能处理多种类型的请求: GET/POST/PUT/DELETE
4. 响应 json 数据自动解析为 js 的对象/数组

### 7.3. 编码实现

- `src/axios/index.js`

```js
/* 发送任意类型请求的函数 */
function axios({ url, method = "GET", params = {}, data = {} }) {
  // 返回一个promise对象
  return new Promise((resolve, reject) => {
    // 处理method(转大写)
    method = method.toUpperCase();

    // 处理query参数(拼接到url上)   id=1&xxx=abc
    /* { id: 1, xxx: 'abc'} */
    let queryString = "";
    Object.keys(params).forEach((key) => {
      queryString += `${key}=${params[key]}&`;
    });
    if (queryString) {
      // id=1&xxx=abc&
      // 去除最后的&
      queryString = queryString.substring(0, queryString.length - 1);
      // 接到url
      url += "?" + queryString;
    }

    // 1. 执行异步ajax请求
    // 创建xhr对象
    const request = new XMLHttpRequest();
    // 打开连接(初始化请求, 没有请求)
    request.open(method, url, true);

    // 发送请求
    if (method === "GET") {
      request.send();
    } else if (method === "POST" || method === "PUT" || method === "DELETE") {
      // 告诉服务器请求体的格式是json
      request.setRequestHeader(
        "Content-Type",
        "application/json;charset=utf-8"
      );
      // 发送json格式请求体参数
      request.send(JSON.stringify(data));
    }

    // 绑定状态改变的监听
    request.onreadystatechange = function () {
      // 如果请求没有完成, 直接结束
      if (request.readyState !== 4) {
        return;
      }
      // 如果响应状态码在[200, 300)之间代表成功, 否则失败
      const { status, statusText } = request;
      // 2.1. 如果请求成功了, 调用resolve()
      if (status >= 200 && status <= 299) {
        // 准备结果数据对象response
        const response = {
          data: JSON.parse(request.response),
          status,
          statusText,
        };
        resolve(response);
      } else {
        // 2.2. 如果请求失败了, 调用reject()
        reject(new Error("request error status is " + status));
      }
    };
  });
}

/* 发送特定请求的静态方法 */
axios.get = function (url, options) {
  return axios(Object.assign(options, { url, method: "GET" }));
};
axios.delete = function (url, options) {
  return axios(Object.assign(options, { url, method: "DELETE" }));
};
axios.post = function (url, data, options) {
  return axios(Object.assign(options, { url, data, method: "POST" }));
};
axios.put = function (url, data, options) {
  return axios(Object.assign(options, { url, data, method: "PUT" }));
};

export default axios;
```

### 7.4.测试

```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>手写ajax请求函数</title>
  </head>
  <body>
    <button onclick="testGet()">发送GET请求</button><br />
    <button onclick="testPost()">发送POST请求</button><br />
    <button onclick="testPut()">发送PUT请求</button><br />
    <button onclick="testDelete()">发送Delete请求</button><br />

    <script src="../dist/atguigu-utils.js"></script>
    <script>
      const { axios } = aUtils;

      /* 1. GET请求: 从服务器端获取数据*/
      function testGet() {
        axios({
          // url: 'http://localhost:3000/posts',
          url: "http://localhost:3000/posts2",
          method: "GET",
          params: {
            id: 1,
            xxx: "abc",
          },
        })
          // axios.get('http://localhost:3000/posts', {params: {id: 1}})
          .then(
            (response) => {
              console.log(response);
            },
            (error) => {
              alert(error.message);
            }
          );
      }

      /* 2. POST请求: 服务器端保存数据*/
      function testPost() {
        axios({
          url: "http://localhost:3000/posts",
          method: "POST",
          data: {
            title: "json-server---",
            author: "typicode---",
          },
        })
          // axios.post('http://localhost:3000/posts', {title: 'aaa', author: 'bbb'})
          .then(
            (response) => {
              console.log(response);
            },
            (error) => {
              alert(error.message);
            }
          );
      }

      /* 3. PUT请求: 服务器端更新数据*/
      function testPut() {
        axios({
          url: "http://localhost:3000/posts/1",
          method: "put",
          data: {
            title: "json-server+++",
            author: "typicode+++",
          },
        })
          // axios.put('http://localhost:3000/posts/1', {title: 'aaa222', author: 'bbb222'})
          .then(
            (response) => {
              console.log(response);
            },
            (error) => {
              alert(error.message);
            }
          );
      }

      /* 2. DELETE请求: 服务器端删除数据*/
      function testDelete() {
        axios({
          url: "http://localhost:3000/posts/2",
          method: "delete",
        })
          // axios.delete('http://localhost:3000/posts/2')
          .then(
            (response) => {
              console.log(response);
            },
            (error) => {
              alert(error.message);
            }
          );
      }
    </script>
  </body>
</html>
```

## 8.手写事件总线

### 8.1.API 说明

1. eventBus: 包含所有功能的事件总线对象
2. eventBus.on(eventName, listener): 绑定事件监听
3. eventBus.emit(eventName, data): 分发事件
4. eventBus.off(eventName): 解绑指定事件名的事件监听, 如果没有指定解绑所有

### 8.2.编码实现

- `src/event-bus/index.js`

```js
const eventBus = {};

/* 
{
  add:  [callback1, callback2]
  delete: [callback3]
}
*/
let callbacksObj = {};

/* 
绑定事件监听
*/
eventBus.on = function (eventName, callback) {
  const callbacks = callbacksObj[eventName];
  if (callbacks) {
    callbacks.push(callback);
  } else {
    callbacksObj[eventName] = [callback];
  }
};

/* 
分发事件
*/
eventBus.emit = function (eventName, data) {
  const callbacks = callbacksObj[eventName];
  if (callbacks && callbacks.length > 0) {
    callbacks.forEach((callback) => {
      callback(data);
    });
  }
};

/* 
移除事件监听
*/
eventBus.off = function (eventName) {
  if (eventName) {
    delete callbacksObj[eventName];
  } else {
    callbacksObj = {};
  }
};

export default eventBus;
```

### 8.3.测试

```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>手写事件总线</title>
  </head>
  <body>
    <script src="../dist/atguigu-utils.js"></script>
    <script>
      const { eventBus } = aUtils;
      eventBus.on("add", (data) => {
        console.log("add", data);
      });
      eventBus.on("add", (data) => {
        console.log("add2", data);
      });
      eventBus.on("delete", (data) => {
        console.log("delete", data);
      });

      // eventBus.off('add')
      // eventBus.off()

      eventBus.emit("add", 123);
      eventBus.emit("delete", "abc");
    </script>
  </body>
</html>
```

## 9.手写消息订阅与发布

### 9.1.API 说明

1. PubSub: 包含所有功能的订阅/发布消息的管理者
2. PubSub.subscribe(msg, subscriber): 订阅消息: 指定消息名和订阅者回调函数
3. PubSub.publish(msg, data): 异步发布消息: 指定消息名和数据
4. PubSub.publishSync(msg, data): 同步发布消息: 指定消息名和数据
5. PubSub.unsubscribe(flag): 取消订阅: 根据标识取消某个或某些消息的订阅

### 9.2.编码实现

```js
/* 
自定义消息订阅与发布
*/

const PubSub = {};
/* 
  {
    add: {
      token1: callback1, 
      token2: callback2
    },
    update: {
      token3: callback3
    }
  }
*/
let callbacksObj = {}; // 保存所有回调的容器
let id = 0; // 用于生成token的标记

// 1. 订阅消息
PubSub.subscribe = function (msgName, callback) {
  // 确定token
  const token = "token_" + ++id;
  // 取出当前消息对应的callbacks
  const callbacks = callbacksObj[msgName];
  if (!callbacks) {
    callbacksObj[msgName] = {
      [token]: callback,
    };
  } else {
    callbacks[token] = callback;
  }
  // 返回token
  return token;
};

// 2. 发布异步的消息
PubSub.publish = function (msgName, data) {
  // 取出当前消息对应的callbacks
  let callbacks = callbacksObj[msgName];
  // 如果有值
  if (callbacks) {
    // callbacks = Object.assign({}, callbacks)
    // 启动定时器, 异步执行所有的回调函数
    setTimeout(() => {
      Object.values(callbacks).forEach((callback) => {
        callback(data);
      });
    }, 0);
  }
};

// 3. 发布同步的消息
PubSub.publishSync = function (msgName, data) {
  // 取出当前消息对应的callbacks
  const callbacks = callbacksObj[msgName];
  // 如果有值
  if (callbacks) {
    // 立即同步执行所有的回调函数
    Object.values(callbacks).forEach((callback) => {
      callback(data);
    });
  }
};

/*
4. 取消消息订阅
  1). 没有传值, flag为undefined
  2). 传入token字符串
  3). msgName字符串
*/
PubSub.unsubscribe = function (flag) {
  // 如果flag没有指定或者为null, 取消所有
  if (flag === undefined) {
    callbacksObj = {};
  } else if (typeof flag === "string") {
    if (flag.indexOf("token_") === 0) {
      // flag是token
      // 找到flag对应的callbacks
      const callbacks = Object.values(callbacksObj).find((callbacks) =>
        callbacks.hasOwnProperty(flag)
      );
      // 如果存在, 删除对应的属性
      if (callbacks) {
        delete callbacks[flag];
      }
    } else {
      // flag是msgName
      delete callbacksObj[flag];
    }
  } else {
    throw new Error("如果传入参数, 必须是字符串类型");
  }
};

export default PubSub;
```

### 9.3.测试

```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>手写消息订阅与发布</title>
  </head>
  <body>
    <script src="../dist/atguigu-utils.js"></script>
    <script>
      const { PubSub } = aUtils;
      // 订阅消息
      PubSub.subscribe("add", (data) => {
        console.log("add()...", data);
      });
      PubSub.subscribe("add", (data) => {
        console.log("add2()...", data);
      });
      const token = PubSub.subscribe("add", (data) => {
        console.log("add3()...", data);
      });
      PubSub.subscribe("update", (data) => {
        console.log("update()...", data);
      });

      // PubSub.unsubscribe(token)
      // PubSub.unsubscribe('add')
      // PubSub.unsubscribe()

      PubSub.publish("add", 12);
      // PubSub.publish('update', 13)
      PubSub.publishSync("update", 12);
      console.log("----");
    </script>
  </body>
</html>
```

## 10.手写 Promise

### 10.1.API 相关

### 10.2.整体实现流程

1. 定义整体结构
2. Promise 构造函数的实现
3. promise.then()/catch()的实现
4. Promise.resolve()/reject()的实现
5. Promise.all/race()的实现
6. Promise.resolveDelay()/rejectDelay()的实现

### 10.3.编码实现

- `src/promise/index.js`

```js
const PENDING = "pending"; // 初始未确定的状态
const RESOLVED = "resolved"; // 成功的状态
const REJECTED = "rejected"; // 失败的状态

/* 
Promise构造函数
*/
function Promise(excutor) {
  const self = this; // Promise的实例对象
  self.status = PENDING; // 状态属性, 初始值为pending, 代表初始未确定的状态
  self.data = undefined; // 用来存储结果数据的属性, 初始值为undefined
  self.callbacks = []; // {onResolved(){}, onRejected(){}}

  /* 
  将promise的状态改为成功, 指定成功的value
  */
  function resolve(value) {
    // 如果当前不是pending, 直接结束
    if (self.status !== PENDING) return;

    self.status = RESOLVED; // 将状态改为成功
    self.data = value; // 保存成功的value

    // 异步调用所有缓存的待执行成功的回调函数
    if (self.callbacks.length > 0) {
      // 启动一个延迟时间为0的定时器, 在定时器的回调中执行所有成功的回调
      setTimeout(() => {
        self.callbacks.forEach((cbsObj) => {
          cbsObj.onResolved(value);
        });
      });
    }
  }

  /* 
  将promise的状态改为失败, 指定失败的reason
  */
  function reject(reason) {
    // 如果当前不是pending, 直接结束
    if (self.status !== PENDING) return;

    self.status = REJECTED; // 将状态改为失败
    self.data = reason; // 保存reason数据

    // 异步调用所有缓存的待执行失败的回调函数
    if (self.callbacks.length > 0) {
      // 启动一个延迟时间为0的定时器, 在定时器的回调中执行所有失败的回调
      setTimeout(() => {
        self.callbacks.forEach((cbsObj) => {
          cbsObj.onRejected(reason);
        });
      });
    }
  }

  // 调用excutor来启动异步任务
  try {
    excutor(resolve, reject);
  } catch (error) {
    // 执行器执行出错, 当前promise变为失败
    console.log("-----");
    reject(error);
  }
}

/* 
用来指定成功/失败回调函数的方法
    1). 如果当前promise是resolved, 异步执行成功的回调函数onResolved
    2). 如果当前promise是rejected, 异步执行成功的回调函数onRejected
    3). 如果当前promise是pending, 保存回调函数
返回一个新的promise对象
    它的结果状态由onResolved或者onRejected执行的结果决定
    2.1). 抛出error ==> 变为rejected, 结果值为error
    2.2). 返回值不是promise   ==> 变为resolved, 结果值为返回值
    2.3). 返回值是promise    ===> 由这个promise的决定新的promise的结果(成功/失败)
*/
Promise.prototype.then = function (onResolved, onRejected) {
  const self = this;

  onResolved = typeof onResolved === "function" ? onResolved : (value) => value; // 将value向下传递
  onRejected =
    typeof onRejected === "function"
      ? onRejected
      : (reason) => {
          throw reason;
        }; // 将reason向下传递

  return new Promise((resolve, reject) => {
    // 什么时候改变它的状态

    /* 
    1. 调用指定的回调函数
    2. 根据回调执行结果来更新返回promise的状态
    */
    function handle(callback) {
      try {
        const result = callback(self.data);
        if (!(result instanceof Promise)) {
          //  2.2). 返回值不是promise   ==> 变为resolved, 结果值为返回值
          resolve(result);
        } else {
          // 2.3). 返回值是promise    ===> 由这个promise的决定新的promise的结果(成功/失败)
          result.then(
            (value) => resolve(value),
            (reason) => reject(reason)
          );
          // result.then(resolve, reject)
        }
      } catch (error) {
        // 2.1). 抛出error ==> 变为rejected, 结果值为error
        reject(error);
      }
    }

    if (self.status === RESOLVED) {
      setTimeout(() => {
        handle(onResolved);
      });
    } else if (self.status === REJECTED) {
      setTimeout(() => {
        handle(onRejected);
      });
    } else {
      // PENDING
      self.callbacks.push({
        onResolved(value) {
          handle(onResolved);
        },
        onRejected(reason) {
          handle(onRejected);
        },
      });
    }
  });
};

/* 
用来指定失败回调函数的方法
catch是then的语法糖
*/
Promise.prototype.catch = function (onRejected) {
  return this.then(undefined, onRejected);
};

/* 
用来返回一个指定vlaue的成功的promise
value可能是一个一般的值, 也可能是promise对象
*/
Promise.resolve = function (value) {
  return new Promise((resolve, reject) => {
    // 如果value是一个promise, 最终返回的promise的结果由value决定
    if (value instanceof Promise) {
      value.then(resolve, reject);
    } else {
      // value不是promise, 返回的是成功的promise, 成功的值就是value
      resolve(value);
    }
  });
};

/* 
用来返回一个指定reason的失败的promise
*/
Promise.reject = function (reason) {
  return new Promise((resolve, reject) => {
    reject(reason);
  });
};

/* 
返回一个promise, 只有当数组中所有promise都成功才成功, 否则失败
*/
Promise.all = function (promises) {
  return new Promise((resolve, reject) => {
    let resolvedCount = 0; // 已经成功的数量
    const values = new Array(promises.length); // 用来保存成功promise的value值
    // 遍历所有promise, 取其对应的结果
    promises.forEach((p, index) => {
      p.then(
        (value) => {
          resolvedCount++;
          values[index] = value;
          if (resolvedCount === promises.length) {
            // 都成功了
            resolve(values);
          }
        },
        (reason) => reject(reason)
      );
    });
  });
};

/* 
返回一个promise, 由第一个完成promise决定
*/
Promise.race = function (promises) {
  return new Promise((resolve, reject) => {
    // 遍历所有promise, 取其对应的结果
    promises.forEach((p) => {
      // 返回的promise由第一个完成p来决定其结果
      p.then(resolve, reject);
    });
  });
};

/* 
返回一个延迟指定时间才成功(也可能失败)的promise
*/
Promise.resolveDelay = function (value, time) {
  return new Promise((resolve, reject) => {
    setTimeout(() => {
      // 如果value是一个promise, 最终返回的promise的结果由value决定
      if (value instanceof Promise) {
        value.then(resolve, reject);
      } else {
        // value不是promise, 返回的是成功的promise, 成功的值就是value
        resolve(value);
      }
    }, time);
  });
};

/* 
返回一个延迟指定时间才失败的promise
*/
Promise.rejectDelay = function (reason, time) {
  return new Promise((resolve, reject) => {
    setTimeout(() => {
      reject(reason);
    }, time);
  });
};

export default Promise;
```

### 10.4.测试

```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>手写Promise</title>
  </head>
  <body>
    <script src="../dist/atguigu-utils.js"></script>
    <script>
      const { Promise } = aUtils;
      new Promise((resolve, reject) => {
        // resolve(1)
        // setTimeout(() => {
        reject(2);
        // }, 1000);
      })
        .then((value) => {
          console.log("onResolve()1");
        })
        .then(
          (value) => {
            console.log("onResolved()2", value);
          },
          (reason) => {
            console.log("onRejected2()", reason);
            // return 3
            // throw 4
            // return new Promise((resolve, reject) =>resolve(5))
            return new Promise((resolve, reject) => reject(6));
          }
        )
        .then(
          (value) => {
            console.log("onResolved3()", value);
          },
          (reason) => {
            console.log("onRejected3()", reason);
            // throw reason
          }
        )
        .catch((reason) => {
          console.log("onRejected4()", reason);
        })
        .then(
          (value) => {
            console.log("onResolved5()", value);
          },
          (reason) => {
            console.log("onRejected5()", reason);
          }
        );
    </script>
  </body>
</html>
```

# 使用 VuePress 搭建在线文档网站

## 1. 在线文档

[VuePress 官方在线文档(opens new window)](https://vuepress.vuejs.org/zh/)

## 2. 搭建基本环境

### 2.1.使用 vue 脚手架创建一个 vue 项目

```bash
# 全局下载 vue 脚手架包
npm install -g @vue/cli
# 创建 vue2 的项目
vue create atguigu-utils_docs
```

### 2.2.使用上 vuepress

```bash
# 下载 VuePress
npm install -D vuepress

# 新建一个文件: docs/README.md
# Hello VuePress!

# 启动文档项目
npx vuepress dev docs
```

## 3. 配置教程的文档

### 3.1.整体结构

```text
|-- docs
  |-- .vuepress
    |-- public
      |-- favicon.ico
      |-- logo.png
      |-- utils.jpg
    |-- config.js
  |-- chapter1
    |-- 01_创建工具包项目.md
    |-- 02_发布到npm中央仓库.md
    |-- 03_使用自定义工具包.md
  |-- chapter2
    |-- 01_函数相关
    |-- 02_数组相关
    |-- 03_对象相关
    |-- 04_字符串相关
    |-- 05_手写带委托的事件监听
    |-- 06_手写ajax请求函数
    |-- 07_手写事件总线
    |-- 08_手写消息订阅与发布
    |-- 09_手写Promise
  |-- chapter3
    |-- README.md
  |-- README.md
|-- package.json
```

### 3.2.`docs/.vuepress/config.js`

```js
// 注意: base的值为github仓库的名称(/不能少)
module.exports = {
  base: "/atguigu_utils-docs/" /* 基础虚拟路径 */,
  dest: "docs/dist" /* 打包文件基础路径, 在命令所在目录下 */,
  title: "自定义工具函数库(系列一)", // 标题
  description: "尚硅谷前端研究院", // 标题下的描述

  themeConfig: {
    // 主题配置
    logo: "/logo.png",
    nav: [
      // 头部导航
      { text: "官网", link: "http://www.atguigu.com" },
      { text: "谷粒学院", link: "http://www.gulixueyuan.com/" },
      {
        text: "学习路线",
        items: [
          { text: "前端", link: "http://www.atguigu.com/web/" },
          { text: "Java", link: "http://www.atguigu.com/kecheng.shtml" },
          { text: "大数据", link: "http://www.atguigu.com/bigdata/" },
        ],
      },
    ],
    sidebar: [
      // 左侧导航
      {
        title: "打包自定义工具库", // 标题
        collapsable: false, // 下级列表不可折叠
        children: [
          // 下级列表
          "chapter1/01_创建工具包项目",
          "chapter1/02_发布到npm中央仓库",
          "chapter1/03_使用自定义工具包",
        ],
      },
      {
        title: "各种自定义",
        collapsable: false,
        children: [
          "chapter2/01_函数相关",
          "chapter2/02_数组相关",
          "chapter2/03_对象相关",
          "chapter2/04_字符串相关",
          "chapter2/05_手写带委托的事件监听",
          "chapter2/06_手写ajax请求函数",
          "chapter2/07_手写事件总线",
          "chapter2/08_手写消息订阅与发布",
          "chapter2/09_手写Promise",
        ],
      },
      {
        title: "快速搭建在线文档网站",
        collapsable: false,
        children: ["chapter3/"],
      },
    ],
    // sidebarDepth: 3 // 左侧导航的深度默认是2级
  },

  head: [
    // 指定网页head图标
    [
      "link",
      { rel: "shortcut icon", type: "image/x-icon", href: `/favicon.ico` },
    ],
  ],
};
```

### 3.3.`docs/README.md`

```bash
---
#首页
home: true
# 图标
heroImage: /utils.jpg
# 按钮文本
actionText: 开始学习 →
# 按钮点击跳转路径
actionLink: /chapter1/01_工具函数库说明

features:
- title: 技术提升
  details: 通过自定义实现函数相关、数组相关、对象相关，字符串相关工具函数； 手写继承、DOM事件监听、ajax请求、事件总线、消息订阅-发布、Promise。极大提升对JS核心技术的理解和编码能力
- title: 面试利器
  details: 中大厂面试问得最多是什么？答：原生JS的理解和编码，咱们这套课程就是为此设计的。
- title: 扩展能力
  details: 如何创建自己的npm工具库？如何快速搭建在线技术或文档站点？我们给你最精简的答案。
---
```

### 3.4.`package.json`

```json
"scripts": {
  "doc:dev": "vuepress dev docs",
  "doc:build": "vuepress build docs",
  "doc:deploy": "gh-pages -d docs/dist"
}
```

## 4. 发布到 github pages

1. 使用 git 管理当前项目
2. 将打包的文档推送到 github pages

```bash
# 下载工具包
npm install -D gh-pages
# 执行打包命令
npm run doc:build
# 执行部署命令
npm run doc:deploy
```
